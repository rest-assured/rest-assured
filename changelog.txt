Changelog next version
----------------------
* Fix duplication of content type in the Spring MockMvc module (thanks to Gemini Kim for pull request)
* Fixed issue with overwriting FailureConfig on settings other configs (#1127) (thanks to Victor Orlovsky for pull request)
* Added version range for the Groovy dependency for the osgi module to be between 2.4 and less than 2.5. This is because the API has changed in Groovy 2.5. (thanks to Rikske54 for pull request)
* Fixed so that using a ResponseSpecBuilder doesn't overwrite the configured config implicitly (issue 1128)
* Add Apache Johnzon object mapper support (thanks to Andriy Redko for pull request)
* Add support for MatcherConfig in RestAssuredMockMvcConfig (#1071) (thanks to Jurriaan Pruijs for pull request)
* Supported for logging when assertion errors thrown from internal matcher #1129 (thanks to Gemini Kim for pull request)
* Fixed so that there no longer are multiple versions of org.springframework:spring-web:jar, leading to inconsistent semantic behaviors (#1143) (thanks to HelloCoCooo for pull request)
* Fixed issues with the use of maven-bundle-plugin which created duplicate classes in the distributed jar-files (#1117) (big thanks to Milen Dyankov, Steven Huypens and Mark Kolich for the help!)
* Breaking changes introduced when solving #1117:
    * io.restassured.mapper.TypeRef has been moved to io.restassured.common.mapper.TypeRef
    * io.restassured.mapper.DataToDeserialize has been moved to io.restassured.common.mapper.DataToDeserialize
    * io.restassured.mapper.ObjectDeserializationContext has been moved to io.restassured.common.mapper.ObjectDeserializationContext
    * io.restassured.mapper.factory.GsonObjectMapperFactory has been moved to io.restassured.path.json.mapper.factory.GsonObjectMapperFactory
    * io.restassured.mapper.factory.Jackson1ObjectMapperFactory has been moved to io.restassured.path.json.mapper.factory.Jackson1ObjectMapperFactory
    * io.restassured.mapper.factory.Jackson2ObjectMapperFactory has been moved to io.restassured.path.json.mapper.factory.Jackson2ObjectMapperFactory
    * io.restassured.mapper.factory.DefaultGsonObjectMapperFactory has been moved to io.restassured.path.json.mapper.factory.DefaultGsonObjectMapperFactory
    * io.restassured.mapper.factory.DefaultJackson1ObjectMapperFactory has been moved to io.restassured.path.json.mapper.factory.DefaultJackson1ObjectMapperFactory
    * io.restassured.mapper.factory.DefaultJackson2ObjectMapperFactory has been moved to io.restassured.path.json.mapper.factory.DefaultJackson2ObjectMapperFactory
    * io.restassured.mapper.resolver.ObjectMapperResolver has been moved to io.restassured.common.mapper.resolver.ObjectMapperResolver
    * io.restassured.exception.PathException has been moved to io.restassured.common.exception.PathException
* Removed deprecated methods:
    * io.restassured.RestAssured
        * withArguments
        * withNoArguments
    * io.restassured.builder.ResponseSpecBuilder
        * expectContent
    * io.restassured.builder.RequestSpecBuilder
        * setContent
        * addParameters
        * addParameter
        * addQueryParameters
        * addQueryParameter
        * addFormParameters
        * addFormParameter
        * addPathParameter
        * addPathParameters
        * setAuthentication
    * io.restassured.specification.ResponseSpecification
        * content
        * specification
    * io.restassured.specification.RequestSpecification
        * content
        * formParameters
        * formParameter
        * pathParameter
        * pathParameters
        * authentication
        * specification
        * parameters
        * parameter
        * queryParameter
        * queryParameters
* Deprecations
    * Deprecated all short versions of "root", for example "root(..)", "appendRoot(..)", "detachRoot(..)". Use "rootPath(..)", "appendRootPath(..)", "detachRootPath(..)" instead. This was introduced for better consistency and clearer intension..
* Rest Assured now requires Java 8 (previously Java 6 was required)
* Removed io.restassured.function.RestAssuredFunction - use java.util.function.Function instead
* Made io.restassured.matcher.ResponseAwareMatcher a proper annotated functional interface
* Made io.restassured.filter.Filter a proper annotated functional interface
* Made io.restassured.listener.ResponseValidationFailureListener a proper annotated functional interface
* Made io.restassured.module.mockmvc.intercept.MockHttpServletRequestBuilderInterceptor a proper annotated functional interface
* Made io.restassured.path.json.mapping.JsonPathObjectDeserializer a proper annotated functional interface
* Upgraded Groovy dependency from 2.4.15 to 2.5.6
* Removed io.restassured.response.ValidatableResponseOptions#specification(..), use io.restassured.response.ValidatableResponseOptions#spec instead
* Removed io.restassured.response.ValidatableResponseOptions#content(..), use io.restassured.response.ValidatableResponseOptions#body(..) instead
* Upgraded Hamcrest from version 1.3 to 2.1
* Made it possible to specify a multi-expectation body with arguments. For example:
    when().
            get("/jsonStore").
    then().
            rootPath("store.book.find { it.author == '%s' }").
            body(
                    "price", withArgs("Nigel Rees"), is(8.95f),
                    "price", withArgs("Evelyn Waugh"), is(12.99f)
            );
  (issue #1154)
* MockMvc module now supports using MediaType for Accept header value (issue #1142). Thanks to Gemini Kim for pull request.
* Support for using "HttpStatus" when validating response status when using MockMvc module. Thanks to Gemini Kim for pull request.

Changelog 3.3.0 (2019-01-11)
----------------------------
* Upgraded json-schema-validator from version 2.2.6 to 2.2.10 (thanks to thorin for pull request)
* Added io.restassured.mapper.TypeRef class that allows you to deserialize the response to a container with generic type. For example:
    List<Map<String, Object>> products = get("/products").as(new TypeRef<List<Map<String, Object>>>() {});
  Currently this only works for JSON :(
* Add logging functionality to the ResponseSpecBuilder, i.e. you can now do:
    ResponseSpecification spec = new ResponseSpecBuilder().log(LogDetail.ALL).build();
  (issue 579). Thanks to Aleksandr Podkutin for pull request!
* httpmime dependency is updated to version 4.5.3 and is now consistent with httpclient (thanks to Rüdiger Herrmann for pull request).
* Updated commons-fileupload from 1.3.1 to 1.3.3 to fix security issues
* Added a new artifact, rest-assured-all, which you can depend on instead of rest-assured to avoid split packages in Java 9+. (thanks to Tomasz Gaweda for pull request)
* Introduces custom listeners on test validation failures. This makes it possible to hook into Rest Assured and get a callback when the test fails with full access to the request/response specification
  as well as the response. You can do this by implementing the "io.restassured.listener.ResponseValidationFailureListener" and add it to the new "FailureConfig". For example:

      given().config(RestAssured.config().failureConfig(failureConfig().with().failureListeners((requestSpec, responseSpec, response) -> log.info("Rest Assured validation failed!")).when(). ..

  (issue 1093) (thanks to Daniel Dyląg for pull request).

Changelog 3.2.0 (2018-10-19)
----------------------------
* Added OSGi support (thanks to ponziani for pull request)
* Make it clear that junit is only a test scope dependency (thanks to Eric Pabst for pull request)
* Changed MockMvcParamConfig.attributeUpdateStrategy() to actually return the attributeUpdateStrategy and not the formParamsUpdateStrategy.
* Added a spring-web-test-client module which let's you unit test Spring Webflux Controllers using the REST Assured DSL. Depend on artifact id "spring-web-test-client" using group id "io.rest-assured" from Maven to use it. Then use io.restassured.module.webtestclient.RestAssuredWebTestClient to get started (thanks to Olga Maciaszek-Sharma for pull request)
* Upgraded to from Groovy 2.4.12 to 2.4.15
* Upgraded Scala from version 2.11.12 to 2.12.7, this also means that the Scala support module now requires Java 8.
* Rest Assured now requires Java 6 (previously Java 5 was required).
* Moved XmlAssertion from io.restassured.assertion package to io.restassured.internal.path.xml since it's an internal class (issue 1051)

Changelog 3.1.1 (2018-08-17)
----------------------------
* Ensure RequestSpecBuilder picks up static config (issue 1012). (thanks to Peter Major for pull request)
* Support multiple 'Set-Cookie' headers in a response (issue 1016). (thanks to runtarinn for pull request)
* Fixed OAuth 1 for GET requests (thanks to Corneliu Duplachi for pull request)
* Add detailed cookie matching to RequestSpecBuilder (thanks to Peter Major for pull request)
* Add File Size to InputStreamEntity (issue 988) (thanks to vjykumar for pull request)
* Properly encodes JSON from InputStream (issue 1040) (thanks to Maksymilian Pawlak for pull request)
* Implemented ability to add headers to a multipart using the MultiPartSpecBuilder

Changelog 3.1.0 (2018-04-20)
-----------------------------
* Fixed generics handling of the detailed cookie matcher (thanks to Rafał Siwiec for pull request)
* Now using Type instead of Class in the API for mapping to Java Objects. For users of the REST Assured API the change is most prominent in the
  "ResponseBodyExtractionOptions" interface where the "as" method now takes a "java.lang.Type" instead of "java.lang.Class". This should not cause
  any backward incompatibilities. However this change also applies to ObjectMapperFactory's where there is a chance of backward incompatibilities
  to arise. For example if you previously had a custom JAXBObjectMapperFactory that looked like this:

     public class MyJAXBObjectMapperFactory implements JAXBObjectMapperFactory {
        public JAXBContext create(Class cls, String charset) {
            ...
        }
     }

  you now need to change it to:

    public class MyJAXBObjectMapperFactory implements JAXBObjectMapperFactory {
        public JAXBContext create(Type cls, String charset) {
            ...
        }
   }

  (note the change from Class to Type). This was needed for swagger integration (issue 980). (thanks to Victor Orlovsky for pull request)
* Add better integration for standard HTTP methods with Apache HttpClient which also solves an issue content-type header being generated for empty GET requests (issue 974) (thanks to Daniel Dyląg for pull request)
* No longer using DEF_CONTENT_CHARSET from Apache HttpClient since it caused compatibility issues (issue 757)
* Fix for #979 Removing Authorization header when setting auth().none() (issue 979) (thanks to jovanovicivan for pull request)
* Fixed so that header equals is case-insensitive (issue 999) (thanks to Todd Bradley for pull request)
* Allow querying (extracting values out of) a request specification using the io.restassured.specification.SpecificationQuerier. For example:
    RequestSpecification spec = ...
    QueryableRequestSpecification queryable = SpecificationQuerier.query(spec);
    String headerValue = queryable.getHeaders().getValue("header");
    String param = queryable.getFormParams().get("someparam");
* Fixed so that it's possible to specify arguments to root paths in multi expectation blocks such as:
        get("/jsonStore").then()
            .root("store.book.find { it.author == '%s' }.price")
            .body(
                    withArgs("Nigel Rees"), is(8.95f),
                    withArgs("Evelyn Waugh"), is(12.99f),
                    withArgs("Herman Melville"), is(8.99f),
                    withArgs("J. R. R. Tolkien"), is(22.99f)
            );
* It's now possible to automatically include additional input fields when using form authentication. Just use the FormAuthConfig and specify the additional values to include using:
    given().auth().form("username", "password", formAuthConfig().withAdditionalFields("firstInputField", "secondInputField"). ..
  REST Assured will automatically parse the HTML page, find the values for the additional fields and include them as form parameters in the login request.

Changelog 3.0.7 (2018-02-09)
-----------------------------
* CookieFilter now conforms to RFC6265 standard by only copying expected cookies instead of all (thanks to Maciej Ciszewski for pull request) (issue 956).
* Prettifier can now prettify empty xml body (issue 960)
* Introduced a "detailed cookie matcher" that allows you to verify more detailed aspects of a cookie, for example:
    given().
        get("/multiCookie").
    then()
        cookie("cookie1", detailedCookie().maxAge(1234567));
  (thanks to Rafał Siwiec for pull request)

Changelog 3.0.6 (2017-11-23)
-----------------------------
* Upgraded to Groovy 2.4.12
* REST Assured now works on Java 9

Changelog 3.0.5 (2017-10-05)
-----------------------------
* Reverted the API to take String instead of CharSequence again since this change introduced an accidental breaking change by not being binary compatible (only source compatible).

Changelog 3.0.4 (2017-10-05)
-----------------------------
* Changed API to take CharSequence instead of String. For example the "get" method in when().get("/something").. now takes a CharSequence instead of String (issue 858) (thanks to weaselmetal for pull request)
* Fixed so that assertions on content type with a ContentType.BINARY argument don't fail for binary content (issue 861) (thanks to Grégory Fouquet for pull request)
* Fixed an issue with two-way SSL whose root cause was Apache HTTP Client v4.5.2. Upgrading to 4.5.3 solved the issue (thanks to Ryan Tighe for pull request)
* Added support for ntlm authentication (issue 869) (thanks to Pawel Cesar Sanjuan Szklarz for pull request)
* Better support for empty GZIP responses (thanks to Sergey Trasko for pull request)
* Treat text/json as JSON content type (thanks to Ionuț Păduraru for pull request)
* RestAssured.oauth2("accessToken") now uses PreemptiveOAuth2HeaderScheme instead of OAuth2Scheme
* Added body params in OAuthRequest (issue 868) (thanks to Corneliu Duplachi for pull request)
* Set authentication once to set in SecurityContextHolder and Principal in method parameter in the MockMvc module (thanks to Leonard Siu for pull request)
* Allow passing multi-parts with content-types not starting with "multipart/" but also containing "multipart+" such as "application/x-hub-multipart+xml" (issue 919)

Changelog 3.0.3 (2017-05-05)
-----------------------------
* Fixed issue with multi-word parameters that were treated as a list (issue 787) (thanks to britka for pull request)
* Merges cookies of HttpServletResponse additionally to the Set-Cookie header (issue 791) (thanks to Andreas Gerstmayr for pull request)
* Removed second negative from exception message "... no supported Content-Type was not specified... " (thanks to Mark N Broadhead for pull request)
* Fixing EOFException for empty GZIP responses (issue 814)
* Update groovy version to fix memory leaks (issue 735) (thanks to Nikolai Gladkov for pull request)
* Improved cookie expiry parsing (issue 563) (thanks to Martin Aun for pull request)
* Improved multipart log output to make it prettier (thanks to Andrey Smirnov for pull request)
* Ignores spacing between content type and charset when validating content types (issue 804)
* Allow specifying default charset (only applicable when HttpMultipartMode is not STRICT) that'll be used when sending multiparts (issue 844)

Changelog 3.0.2 (2017-01-20)
-----------------------------
* Don't join root and path with '.' if path starts with array indexing (thanks to feshbach for pull request)
* Updated SSLConfig to allow keystore and truststore passwords to differ (thanks to mike42 for pull request)
* SSLConfig#getKeyStore() was returning trustStore rather than keyStore (thanks to mike42 for pull request)
* Added ability to get Cookies as a list (using Cookies#asList)
* Added new functionality to filters that allows removing and replacing headers and cookies.
* Fixed so that form parameters (i.e. String-values) does get merged correctly with the multipart parameters (issue 762) (thanks to Klaus Dorninger for pull request)
* Fixed so that the boundary of a request is set explicitly in the "Content-Type" header of the request (issue 762) (thanks to Klaus Dorninger for pull request)
* Fixed error message thrown by RestAssuredMockMvc that hinted at using the regular RestAssured API instead of the MockMvc variant (thanks to Toshiaki Maki for pull request)
* Fixed mismatch description from Hamcrest Matcher that previously was ignored for status codes (thanks to Javier Romero for pull request)
* Added support for ordered filters. Implement the io.restassured.filter.OrderedFilter interface and specify the precedence (thanks to jcravi for initial pull request).
* Fixed so that you can download binary data with the RestAssuredMockMvc module (thanks to Sergey Bespalov for pull request)
* Improved exception message when there's no supported (de-)serialization library in classpath (issue 788)

Changelog 3.0.1 (2016-09-02)
-----------------------------
* Fixed issues with colliding keys in multi-expectations for body and header validations. For example if "/x" returns the JSON { "x" : 2 } this would (previously) not throw an assertion error:
    when().
         get("/x").
    then().
         body("x", greaterThan(1),
              "x", equalTo(5),
              "x", lessThan(3));
  The reason was the only the last first and last "x" expectation were taken into account (issue 714).
* Removed log.warn(..) messages from internal classes (issue 715)
* Cookie attributes are no longer sent in request in accordance with RFC6265. Thanks to Maciej Gawinecki for pull request. (issue 720)
* Mismatch description from TypeSafeDiagnosingMatcher is no longer ignored for when validating cookies. Thanks to Maciej Gawinecki for pull request. (issue 717)
* REST Assured no longer forces the use of the platform charset when parsing JSON as string when combined with expectations (issue 728)
* Don't append '.' to root path if given path starts with array indexing. Thanks to Tobias Johansson for pull request (issue 727).
* Removed the need for the cookie max age value to be greater than or equal to -1 (issue 732).
* Fixed memory leak in JSONAssertion. Big thanks to Andrey for pull request and investigation (issue 735).
* Releasing loaded classes in XmlAssertion after expression evaluation to reduce memory foot print.

Changelog 3.0.0 (2016-06-03)
-----------------------------
* Upgrading scribe dependencies to latest version 2.5.3 (thanks to Aniket for pull request)
* Added ability to specify an empty access token for OAuth1 authentication. Use com.jayway.restassured.config.OAuthConfig#addEmptyTokenToBaseString(boolean) to configure this.
* Allow to specify -1 as Cookie Max-Age in accordance with RFC 6265 (https://tools.ietf.org/html/rfc6265#page-20). Thanks to Timofey Dmitriev for pull request (issue 580).
* com.jayway.restassured.builder.RequestSpecBuilder#addMultiPart(MultiPartSpecification) is now public (issue 669)
* Support for setting session attributes in the Spring MockMvc module using the "sessionAttr" and "sessionAttrs" methods (thanks to sneyyar for pull request) (issue 671)
* It's now possible to map to java objects when extracting from a list in JsonPath. For example JsonPath.from(json).getList("store.books", Book.class).
* Added CookieFilter (com.jayway.restassured.filter.cookie.CookieFilter).  The cookie filter can be used to keep track of all the cookies sent by the server and use
  them in subsequent requests.  It might come in handy when more than just com.jayway.restassured.filter.session.SessionFilter is needed. (thanks to Ranil Wijeyratne for pull request)
* It's now possible to pass a File to the body/content method of the RequestSpecification when content-type is set to JSON, XML or TEXT. The contents of this file will be sent to the server (issue 674)
* Fixed an issue where the Jackson and Jackson2 (Faster Jackson) object mappers didn't fully took charset into account when serializing POJO to String (issue 677).
* Added ability to instruct REST Assured whether or not to URL encode the request URI when it's presented in the request specification log.
  This is configured using the com.jayway.restassured.config.LogConfig#urlEncodeRequestUri method. By default url encoding of the request uri is enabled to show what the URL targeted by REST Assured actually looks like for real.
  But there may be cases where you want to make the URI more readable and this is when you might want to consider setting urlEncodeRequestUri to false (issue 678)
* Upgraded Groovy from 2.4.4 to 2.4.6
* Upgraded http-client from 4.5.1 to 4.5.2
* Improved JsonPath error messages when trying to verify a path with a parent that doesn't exist. For example if we have the following JSON document:
    { "myThing" : { "name" : "ThingName" } }
  and we try to test it like so:
    when().get("/thing").then().body("myThing1.name", equalTo("ThingName")); // Notice myThing1 is invalid
  we now get an AssertionError like this:
    1 expectation failed.
    JSON path store.unknown.unknown.get(0) doesn't match.
    Expected: (a collection containing "none")
    Actual: null
  whereas previously you would get an IllegalArgumentException with an error message like this:
    Cannot get property 'name' on null object
  (issue 668)
* Multipart uploads now take the content-type boundary into account. For example you can specify:
    given().contentType("multipart/mixed; boundary=abcdef").multiPart(..). ..
  which will use the specified boundary of "abcdef" instead of generating a "random" one. It's also possible to specify a default boundary
  in the MultiPartConfig:
    given().config(config().multiPartConfig(multiPartConfig().defaultBoundary("abcdef"))). ..
  (issue 670)
* Fixed an issue with path parameters where REST Assured would say that a path parameter was not applied if the value was shorter than the template name in cases where you had defined multiple templates between two slashes (issue 683)
* Fixed so that it's possible to declare whether or not XmlPath and Rest Assured should use care about XML namespaces, validation and/or allow doc type declaration.
  To configure this when using XmlPath do:
    XmlPath xmlPath = new XmlPath(xml).using(xmlPathConfig().namespaceAware(false)); // replace "namespaceAware" with "validation" or "allowDocTypeDeclaration" if needed
  And like this if using REST Assured DSL:
    given().config(RestAssured.config().xmlConfig(xmlConfig().namespaceAware(false))). ..
* Deprecated com.jayway.restassured.filter.log.LogDetail#PATH since it actually configured REST Assured to log the request URI and not only the path. Use com.jayway.restassured.filter.log.LogDetail#URI instead (issue 687).
* Added NumberReturnType.BIG_INTEGER which allows you to configure JsonPath to return non-decimal values as BigInteger (thanks to Jacob Krieger for pull request) (issue 695)
* Upgraded spring-security from 4.0.2.RELEASE to 4.1.0.RELEASE in MockMvc module (optional dependency)
* Upgraded spring from 4.2.0.RELEASE to 4.2.6.RELEASE in the MockMvc module
* Upgraded commons-lang3 from 3.3.2 to 3.4
* Improved proxy authentication to use Apache HTTP Client's built in features (issue 693)
* Fixed NPE trying to close an empty response which was read as an inputstream (issue 685)
* Added ability to remove headers from a filter by using the FilterableRequestSpecification#removeHeader method (issue 539)
* Removed the following deprecated methods:
    - io.restassured.specification.AuthenticationSpecification.certificate(java.lang.String, java.lang.String, java.lang.String, int) (use io.restassured.specification.AuthenticationSpecification.certificate(java.lang.String, java.lang.String, io.restassured.authentication.CertificateAuthSettings) instead)
    - io.restassured.RestAssured.requestContentType(io.restassured.http.ContentType) (use a io.restassured.builder.RequestSpecBuilder, set the content-type and apply it to io.restassured.RestAssured.requestSpecification)
    - io.restassured.RestAssured.responseContentType(java.lang.String) (Use io.restassured.builder.ResponseSpecBuilder.expectContentType(io.restassured.http.ContentType) and apply it to io.restassured.RestAssured.responseSpecification instead)
    - io.restassured.config.EncoderConfig.appendDefaultContentCharsetToStreamingContentTypeIfUndefined(java.lang.boolean) (use io.restassured.config.EncoderConfig.appendDefaultContentCharsetToContentTypeIfUndefined(boolean) instead)
    - io.restassured.specification.FilterableRequestSpecification.getRequestContentType() (use io.restassured.specification.FilterableRequestSpecification.getContentType() instead)
    - io.restassured.RestAssured.requestContentType() (If you really need to know this then create a filter)
    - io.restassured.RestAssured.responseContentType() (If you need to know this then extract it from the response)
    - io.restassured.RestAssured.certificate(java.lang.String, java.lang.String, java.lang.String, int) (use io.restassured.RestAssured.certificate(java.lang.String, java.lang.String, io.restassured.authentication.CertificateAuthSettings) instead)
    - io.restassured.filter.FilterContext.getRequestMethod() (use io.restassured.specification.FilterableRequestSpecification.getMethod() instead)
    - io.restassured.filter.FilterContext.getRequestPath() (use io.restassured.specification.FilterableRequestSpecification.getDerivedPath() instead)
    - io.restassured.filter.FilterContext.getOriginalRequestPath() (use io.restassured.specification.FilterableRequestSpecification.getUserDefinedPath() instead)
    - io.restassured.filter.FilterContext.getRequestURI() (use io.restassured.specification.FilterableRequestSpecification.getURI() instead)
    - io.restassured.filter.FilterContext.getCompleteRequestPath() (use io.restassured.specification.FilterableRequestSpecification.getURI() instead)
    - io.restassured.filter.log.LogDetail.PATH (use io.restassured.filter.log.LogDetail.URI instead)
    - io.restassured.module.mockmvc.specification.MockMvcRequestSpecification.resultHandlers (use io.restassured.module.mockmvc.response.ValidatableMockMvcResponse.apply(..) instead)
    - io.restassured.mapper.ObjectMapper.JACKSON (isn't needed anymore)
    - io.restassured.mapper.ObjectMapper.GSON (isn't needed anymore)
    - io.restassured.mapper.ObjectMapper.JAXB (isn't needed anymore)
    - io.restassured.config.SSLConfig.getPassword() (use io.restassured.config.SSLConfig.getKeyStorePassword() instead)
* Renamed method com.jayway.restassured.specification.RequestLogSpecification.path(..) to com.jayway.restassured.specification.RequestLogSpecification.uri(..)
* Added support for automatically recognizing content-type "text/json" as JSON
* Changed Maven groupId from com.jayway.restassured to io.rest-assured
* Changed package name from com.jayway.restassured to io.restassured
* Removed ability send requests directly from the response specification. This means that you can't do for example "expect().get("/")" anymore. Use "when().get("/")" instead.
* Changed io.restassured.specification.FilterableRequestSpecification.getMethod() to return a String instead of an instance of io.restassured.http.Method since custom HTTP verbs are now supported
* All HTTP verbs now support data in the body (for example TRACE, OPTIONS etc)
* Removed io.restassured.specification.RequestSpecification.then() since it's confusingly similar to the "then" method in RequestSender. Use then "when" method instead.
* You can now use custom http methods/verbs with REST Assured by making using the the "request method" in the DSL (or from statically importing a io.restassured.RestAssured.request(..)). For example:
    when().request("CONNECT", "/somewhere").then().statusCode(200);
  It you can also supply a predefined http method (defined in the io.restassured.http.Method enum):
    when().request(Method.GET, "/lotto").then().statusCode(200);
  This API has also been implemented for the MockMvc module (but MockMvc doesn't support arbitrary http methods as of now).
* Fixed so that query parameters are included in the request URI in the Spring MockMvc module (issue 699) (thanks to lee myeong hyeon for pull request)
* Handles non-integer cookie versions in responses better (issue 701)
* Added ability to use ResponseAwareMatcher for headers. For example you can now use attributes from the response body to validate a Location header.
  Let's say that "/redirect" returns the json document { "id" : 1 } and returns a redirect to a location ending with this id. If you want to validate the
  Location header invariant you can do:
    given().
            redirects().follow(false).
    when().
            get("/redirect").
    then().
            statusCode(301).
            header("Location", response -> endsWith("/redirect/"+response.path("id")));
  This has also been implemented for the MockMvc module (issue 692).
* Moved classes Cookie, Cookies, Header and Headers from package com.jayway.restassured.response to io.restassured.http since they were used for both requests and responses.
* Moved io.restassured.internal.mapper.ObjectMapperType to io.restassured.mapper since ObjectMapperType should not be internal
* Deprecated all long versions "parameter" as well as "content". Here's a full list:
    io.restassured.builder.RequestSpecBuilder:
        - io.restassured.builder.RequestSpecBuilder.setContent(byte[]) (use io.restassured.builder.RequestSpecBuilder.setBody(byte[]) instead)
        - io.restassured.builder.RequestSpecBuilder.setContent(java.lang.Object) (use io.restassured.builder.RequestSpecBuilder.setBody(Object) instead)
        - io.restassured.builder.RequestSpecBuilder.setContent(java.lang.Object, io.restassured.mapper.ObjectMapper) (use io.restassured.builder.RequestSpecBuilder.setBody(java.lang.Object, io.restassured.mapper.ObjectMapper) instead)
        - io.restassured.builder.RequestSpecBuilder.setContent(java.lang.Object, io.restassured.mapper.ObjectMapperType) (use io.restassured.builder.RequestSpecBuilder.setBody(java.lang.Object, io.restassured.mapper.ObjectMapperType) instead)
        - io.restassured.builder.RequestSpecBuilder.setContent(java.lang.Object, io.restassured.mapper.ObjectMapperType) (use io.restassured.builder.RequestSpecBuilder.setBody(java.lang.Object, io.restassured.mapper.ObjectMapperType) instead)
        - io.restassured.builder.RequestSpecBuilder.setContent(java.lang.String) (use io.restassured.builder.RequestSpecBuilder.setBody(java.lang.String) instead)
        - io.restassured.builder.RequestSpecBuilder.addParameter(java.lang.String, java.util.Collection<?>) (use io.restassured.builder.RequestSpecBuilder.addParam(java.lang.String, java.util.Collection<?>) instead)
        - io.restassured.builder.RequestSpecBuilder.addParameter(java.lang.String, java.lang.Object...) (use io.restassured.builder.RequestSpecBuilder.addParam(java.lang.String, java.lang.Object...) instead)
        - io.restassured.builder.RequestSpecBuilder.addParameters (use io.restassured.builder.RequestSpecBuilder.addParams instead)
        - io.restassured.builder.RequestSpecBuilder.addFormParameter(java.lang.String, java.util.Collection<?>) (use io.restassured.builder.RequestSpecBuilder.addParams instead)
        - io.restassured.builder.RequestSpecBuilder.addFormParameter(java.lang.String, java.lang.Object...) (use io.restassured.builder.RequestSpecBuilder.addFormParam(java.lang.String, java.lang.Object...) instead)
        - io.restassured.builder.RequestSpecBuilder.addFormParameters (use io.restassured.builder.RequestSpecBuilder.addFormParams instead)
        - io.restassured.builder.RequestSpecBuilder.addPathParameter(java.lang.String, java.util.Collection<?>) (use io.restassured.builder.RequestSpecBuilder.addParams instead)
        - io.restassured.builder.RequestSpecBuilder.addPathParameters(java.lang.String, java.lang.Object, java.lang.Object...) (use io.restassured.builder.RequestSpecBuilder.addPathParams(java.lang.String, java.lang.Object, java.lang.Object...) instead)
        - io.restassured.builder.RequestSpecBuilder.addPathParameters (use (use io.restassured.builder.RequestSpecBuilder.addPathParams instead)
        - io.restassured.builder.RequestSpecBuilder.addQueryParameter(java.lang.String, java.util.Collection<?>) (use io.restassured.builder.RequestSpecBuilder.addParams instead)
        - io.restassured.builder.RequestSpecBuilder.addQueryParameter(java.lang.String, java.lang.Object...) (use io.restassured.builder.RequestSpecBuilder.addQueryParam(java.lang.String, java.lang.Object...) instead)
        - io.restassured.builder.RequestSpecBuilder.addQueryParameters (use io.restassured.builder.RequestSpecBuilder.addQueryParams instead)
        - io.restassured.builder.RequestSpecBuilder.setAuthentication (use io.restassured.builder.RequestSpecBuilder.setAuth instead)
    io.restassured.builder.ResponseSpecBuilder:
        - io.restassured.builder.ResponseSpecBuilder.expectContent(org.hamcrest.Matcher<?>) (Use io.restassured.builder.ResponseSpecBuilder.expectBody(org.hamcrest.Matcher<?>) instead)
        - io.restassured.builder.ResponseSpecBuilder.expectContent(java.lang.String, org.hamcrest.Matcher<?>) (Use io.restassured.builder.ResponseSpecBuilder.expectBody(java.lang.String, org.hamcrest.Matcher<?>) instead)
        - io.restassured.builder.ResponseSpecBuilder.expectContent(java.lang.String, java.util.List<io.restassured.specification.Argument>, org.hamcrest.Matcher<?>) (Use io.restassured.builder.ResponseSpecBuilder.expectBody(java.lang.String, java.util.List<io.restassured.specification.Argument>, org.hamcrest.Matcher<?>) instead)
    io.restassured.specification.RequestSpecification:
        - io.restassured.specification.RequestSpecification.content(byte[]) (Use io.restassured.specification.RequestSpecification.body(byte[]) instead)
        - io.restassured.specification.RequestSpecification.content(java.io.File) (Use io.restassured.specification.RequestSpecification.body(java.io.File) instead)
        - io.restassured.specification.RequestSpecification.content(java.io.InputStream) (Use io.restassured.specification.RequestSpecification.body(java.io.InputStream) instead)
        - io.restassured.specification.RequestSpecification.content(java.lang.Object) (Use io.restassured.specification.RequestSpecification.body(java.lang.Object) instead)
        - io.restassured.specification.RequestSpecification.content(java.lang.Object, io.restassured.mapper.ObjectMapper) (Use io.restassured.specification.RequestSpecification.body(java.lang.Object, io.restassured.mapper.ObjectMapper) instead)
        - io.restassured.specification.RequestSpecification.content(java.lang.Object, io.restassured.mapper.ObjectMapperType) (Use io.restassured.specification.RequestSpecification.body(java.lang.Object, io.restassured.mapper.ObjectMapperType) instead)
        - io.restassured.specification.RequestSpecification.content(java.lang.String) (Use io.restassured.specification.RequestSpecification.body(java.lang.String) instead)
        - io.restassured.specification.RequestSpecification.authentication (Use io.restassured.specification.RequestSpecification.auth instead)
        - io.restassured.specification.RequestSpecification.parameter(java.lang.String, java.util.Collection<?>) (Use io.restassured.specification.RequestSpecification.param(java.lang.String, java.util.Collection<?>) instead)
        - io.restassured.specification.RequestSpecification.parameter(java.lang.String, java.lang.Object...) (Use io.restassured.specification.RequestSpecification.param(java.lang.String, java.lang.Object...) instead)
        - io.restassured.specification.RequestSpecification.parameters(java.util.Map<java.lang.String,?>) (Use io.restassured.specification.RequestSpecification.params(java.util.Map<java.lang.String,?>) instead)
        - io.restassured.specification.RequestSpecification.parameters(java.lang.String, java.lang.Object, java.lang.Object...) (Use io.restassured.specification.RequestSpecification.params(java.lang.String, java.lang.Object, java.lang.Object...) instead)
        - io.restassured.specification.RequestSpecification.formParameter(java.lang.String, java.util.Collection<?>) (Use io.restassured.specification.RequestSpecification.formParam(java.lang.String, java.util.Collection<?>) instead)
        - io.restassured.specification.RequestSpecification.formParameter(java.lang.String, java.lang.Object...) (Use io.restassured.specification.RequestSpecification.formParam(java.lang.String, java.lang.Object...) instead)
        - io.restassured.specification.RequestSpecification.formParameters(java.util.Map<java.lang.String,?>) (Use io.restassured.specification.RequestSpecification.formParams(java.util.Map<java.lang.String,?>) instead)
        - io.restassured.specification.RequestSpecification.formParameters(java.lang.String, java.lang.Object, java.lang.Object...) (Use io.restassured.specification.RequestSpecification.formParams(java.lang.String, java.lang.Object, java.lang.Object...) instead)
        - io.restassured.specification.RequestSpecification.queryParameter(java.lang.String, java.util.Collection<?>) (Use io.restassured.specification.RequestSpecification.queryParam(java.lang.String, java.util.Collection<?>) instead)
        - io.restassured.specification.RequestSpecification.queryParameter(java.lang.String, java.lang.Object...) (Use io.restassured.specification.RequestSpecification.queryParam(java.lang.String, java.lang.Object...) instead)
        - io.restassured.specification.RequestSpecification.queryParameters(java.util.Map<java.lang.String,?>) (Use io.restassured.specification.RequestSpecification.queryParams(java.util.Map<java.lang.String,?>) instead)
        - io.restassured.specification.RequestSpecification.queryParameters(java.lang.String, java.lang.Object, java.lang.Object...) (Use io.restassured.specification.RequestSpecification.queryParams(java.lang.String, java.lang.Object, java.lang.Object...) instead)
        - io.restassured.specification.RequestSpecification.pathParameter(java.lang.String, java.lang.Object...) (Use io.restassured.specification.RequestSpecification.pathParam(java.lang.String, java.lang.Object...) instead)
        - io.restassured.specification.RequestSpecification.pathParameters(java.util.Map<java.lang.String,?>) (Use io.restassured.specification.RequestSpecification.pathParams(java.util.Map<java.lang.String,?>) instead)
        - io.restassured.specification.RequestSpecification.pathParameters(java.lang.String, java.lang.Object, java.lang.Object...) (Use io.restassured.specification.RequestSpecification.pathParams(java.lang.String, java.lang.Object, java.lang.Object...) instead)
        - io.restassured.specification.RequestSpecification.specification (Use io.restassured.specification.RequestSpecification.spec instead)
    io.restassured.specification.ResponseSpecification:
        - io.restassured.specification.ResponseSpecification#rootPath(java.lang.String) (Use io.restassured.specification.ResponseSpecification.root(java.lang.String) instead)
        - io.restassured.specification.ResponseSpecification.rootPath(java.lang.String, java.util.List<io.restassured.specification.Argument>) (Use io.restassured.specification.ResponseSpecification.rootPath(java.lang.String, java.util.List<io.restassured.specification.Argument>) instead)
        - io.restassured.specification.ResponseSpecification.noRootPath (Use io.restassured.specification.ResponseSpecification.noRoot instead)
        - io.restassured.specification.ResponseSpecification.content(java.util.List<io.restassured.specification.Argument>, org.hamcrest.Matcher, java.lang.Object...) (Use io.restassured.specification.ResponseSpecification.body(java.util.List<io.restassured.specification.Argument>, org.hamcrest.Matcher, java.lang.Object...) instead)
        - io.restassured.specification.ResponseSpecification.content(org.hamcrest.Matcher<?>, org.hamcrest.Matcher<?>...) (Use io.restassured.specification.ResponseSpecification.body(org.hamcrest.Matcher<?>, org.hamcrest.Matcher<?>...) instead)
        - io.restassured.specification.ResponseSpecification.content(java.lang.String, java.util.List<io.restassured.specification.Argument>, org.hamcrest.Matcher, java.lang.Object...) (Use io.restassured.specification.ResponseSpecification.body(java.lang.String, java.util.List<io.restassured.specification.Argument>, org.hamcrest.Matcher, java.lang.Object...) instead)
        - io.restassured.specification.ResponseSpecification.content(java.lang.String, org.hamcrest.Matcher<?>, java.lang.Object...) (Use io.restassured.specification.ResponseSpecification.body(java.lang.String, org.hamcrest.Matcher<?>, java.lang.Object...) instead)
        - io.restassured.specification.ResponseSpecification.specification (Use io.restassured.specification.ResponseSpecification.spec instead)
    io.restassured.RestAssured:
        - io.restassured.RestAssured.withArguments (Use io.restassured.RestAssured.withArgs instead)
        - io.restassured.RestAssured.withNoArguments (Use io.restassured.RestAssured.withNoArgs instead)
* Renamed the following methods:
    - io.restassured.authentication.CertificateAuthSettings.keystoreType to io.restassured.authentication.CertificateAuthSettings.keyStoreType
    - io.restassured.authentication.CertificateAuthSettings.getKeystoreType to io.restassured.authentication.CertificateAuthSettings.getKeyStoreType
    - io.restassured.specification.RequestSpecification.keystore to io.restassured.specification.RequestSpecification.keyStore
    - io.restassured.RestAssured.keystore to io.restassured.RestAssured.keyStore
    - io.restassured.builder.RequestSpecBuilder.setKeystore to io.restassured.builder.RequestSpecBuilder.setKeyStore
* You can now do multipart file uploading for all HTTP verbs (even GET, OPTIONS etc)

Changelog 2.9.0 (2016-03-04)
-----------------------------
* Added support for composing a Hamcrest matcher with a ResponseAwareMatcher when using a ResponseAwareMatcherComposer
* Automatically escapes JsonPath and XmlPath fragments that contains a hyphen and an index lookup operator. For example consider the following JSON document:
    { "some-list" : ["one", "two"] }
  Previously you had to escape "some-list" manually if you wanted to get first element out of the list:
    JsonPath jsonPath = ...
    String firstElement = jsonPath.getString("'some-list'[0]"); // one
  Now no explicit escaping is necessary:
    String firstElement = jsonPath.getString("some-list[0]"); // one
  But this means that if you previously had a JSON document like this:
    { "some-list[0]" : ["one", "two"] }
  you would now have to escape it:
    String firstElement = jsonPath.getString("'some-list[0]'[0]"); // one
  which makes this an (unlikely but still) non-backward compatible change (issue 564).
* Added support for multipart DELETE requests (issue 634)
* It's now possible to use empty and whitespace path parameters (issue 631)
* Replace deprecated HttpEntity.consume with EntityUtils.consume to fix problems with connections not closing properly (issue 633) (thanks to Marin Dzhigarov and Julian Engelhardt for help and PR)
* Fixing NullPointerException for GET requests with an empty body (issue 642)
* Form authentication for fully-qualified URIs now uses the URI specified in the request instead of just localhost (issue 641)
* Improve escaping for XmlPath's containing colon. For example you can now do like this without manually having to escape anything in the path: "x:something.x:y[0]" (issue 647)
* Getting an attribute value from an XmlPath expression that doesn't exists now returns null instead of an empty list (issue 650).
* Deprecated com.jayway.restassured.config.SSLConfig#getPassword, use com.jayway.restassured.config.SSLConfig#getKeyStorePassword instead
* Major improvements of certificate authentication. You can now use a keystore (without trust store) and a keystore and trust store at the same time.
* Non-backward compatible change: keystore was previously used as a truststore. You must change "given().keystore(..)" to "given().trustStore(..)", "RestAssured.keystore(..)" to "RestAssured.trustStore(..)" and "SSLConfig.keystore(..)" to "SSLConfig.trustStore(..)". Sorry!

Changelog 2.8.0 (2015-12-18)
-----------------------------
* Modify HttpClientConfig so parameter methods respect previous configuration (issue 612). Thanks to Adam Clarkson for pull request.
* Fixed issue that caused filter context properties to be removed between filter invocations
* Added support for measuring time. For example:
    long timeInMs = get("/lotto").time()
  or using a specific time unit:
    long timeInSeconds = get("/lotto").timeIn(SECONDS);
  where "SECONDS" is just a standard TimeUnit. You can also validate it using the validation DSL:
    when().
            get("/lotto").
    then().
            time(lessThan(2000L)); // Milliseconds
  or
    when().
            get("/lotto").
    then().
            time(lessThan(2L), SECONDS);
  Please note that response time measurement should be performed when the JVM is hot! (i.e. running a response time measurement when only running a single test will yield erroneous results)
  This is also implemented in the Spring MockMvc module (issue 493)
* Deprecated: com.jayway.restassured.filter.FilterContext#getRequestMethod, use com.jayway.restassured.specification.FilterableRequestSpecification#getMethod instead.
* Deprecated: com.jayway.restassured.filter.FilterContext#getRequestPath, use com.jayway.restassured.specification.FilterableRequestSpecification#getUserDefinedPath instead.
* Deprecated: com.jayway.restassured.filter.FilterContext#getRequestURI, use com.jayway.restassured.specification.FilterableRequestSpecification#getURI instead.
* Deprecated: com.jayway.restassured.filter.FilterContext#getOriginalRequestPath, use com.jayway.restassured.specification.FilterableRequestSpecification#getUserDefinedPath instead.
* Deprecated: com.jayway.restassured.specification.FilterableRequestSpecification#getRequestContentType, use com.jayway.restassured.specification.FilterableRequestSpecification#getContentType instead.
* Added com.jayway.restassured.http.Method enum that represents the various HTTP methods that may be used in REST Assured
* Added getUnnamedPathParams method to com.jayway.restassured.specification.FilterableRequestSpecification which returns all unnamed path parameters
* Added getUnnamedPathParamValues method to com.jayway.restassured.specification.FilterableRequestSpecification which returns all unnamed path parameter values
* Added getNamedPathParams method to com.jayway.restassured.specification.FilterableRequestSpecification which returns all named path parameters
* Non-backward compatible change: com.jayway.restassured.specification.FilterableRequestSpecification#getPathParams now returns both unnamed and named path parameters (before only named parameters were returned).
* com.jayway.restassured.specification.FilterableRequestSpecification#getQueryParams, getRequestParams, getFormParams and getPathParams now returns a Map of String -> String whereas before they returned a Map of String -> Object.
* It's now possible to change the request path from a filter, use the "path" method in the "requestSpec" (com.jayway.restassured.specification.FilterableRequestSpecification#path).
* You can now specify both named and unnamed path params at the same time
* Added ability to remove parameters from the FilterableRequestSpecification. Use the remove methods such as "removeQueryParam".
* Better error messages when unnamed path parameters are null.
* Slightly improved logging in Spring MockMvc module
* Removed the use of StandardCharset from DecoderConfig which prevented EncoderConfig to be used on Java 6 and older.
* Multipart patch no longer produces an exception on a call that returns status other than 200 (issue 615)

Changelog 2.7.0 (2015-10-31)
-----------------------------
* Significantly reduce sized of scala-support distribution package
* Removed the use of StandardCharset from EncoderConfig which prevented EncoderConfig to be used on Java 6 and older.
* Added support for sending a request body in a GET request (issue 544). Thanks to Manuel Möhlmann for pull request.
* Response content-type validation now works correctly even if the response body is empty (issue 566). Thanks to Manuel Möhlmann for pull request.
* Fixing dead links in javadocs (issue 605). Thanks to Ben Severson for pull request.
* Changes to com.jayway.restassured.filter.FilterContext:
   1. getRequestPath now only returns the the actual path of the request URI (previously this returned the request URI) (non-backward compatible change)
   2. getRequestURI returns the entire request URI (new method)
   3. getCompleteRequestPath has been deprecated, use getRequestURI
   4. getOriginalRequestPath has been added which returns the path of the request BEFORE path parameters have been applied to it
* Deprecated "resultHandlers" method in MockMvcRequestSpecification and added "apply" method to com.jayway.restassured.module.mockmvc.response.ValidatableMockMvcResponse that should be used instead.
  For example previously you did "given().resultHandlers(print()).when().get("/x")" but now you do "get("/x").then().apply(print())" (issue 607)
* Automatically escapes "class" keyword in JsonPath and XmlPath (issue 598)
* Taking DecoderConfig into account when parsing non-string content (issue 599)
* It's now possible to supply MockMvcConfigurers when calling standaloneSetup in the Spring Mock MVC module. For example:
      given().standaloneSetup(new Controller1(), springSecurity()). ..
* Automatically adds supports for spring rest docs path parameter documentation if spring-restdocs-mockmvc is in classpath. This can be disabled using the MockMvcConfig (issue 606).
* It's now possible to change port, base path etc from a filter (issue 600)
* Added support for specifying preemptive basic authentication for proxies. For example:
    given().proxy(auth("username", "password")).when() ..
  where "auth" is statically imported from com.jayway.restassured.specification.ProxySpecification (issue 597).
* Added getUUID method to JsonPath and XmlPath (thanks to Libor Ondrušek for the pull request)

Changelog 2.6.0 (2015-10-09)
-----------------------------
* Changed com.jayway.restassured.config.HttpClientConfig$HttpClientFactory from an abstract class to an interface in order to create it as a lambda express in Java 8. Before you had to do like this:
    given().config(RestAssured.config().httpClientConfig(httpClientConfig().httpClientFactory(new HttpClientConfig.HttpClientFactory() {
        @Override
        public HttpClient createHttpClient() {
            return new SystemDefaultHttpClient();
        }
    }));
  but now you can just use a lambda expression or method reference:
    given().config(RestAssured.config().httpClientConfig(httpClientConfig().httpClientFactory(SystemDefaultHttpClient::new));
* Fixed so that the "multiPart(String name, File file, String mimeType)" method doesn't use default control name (issue 588)
* Added support for setting multipart filename when passing in an object to multiPart method (issue 587)
* Multipart file-uploading now takes encoder config into account when serializing content. For example if you're trying to serialize an object
  using mime-type "application/vnd.ms-excel" in a multipart then you can register that it should be serialize as JSON:
    Greeting greeting = new Greeting();
    greeting.setFirstName("John");
    greeting.setLastName("Doe");

    given().
           config(config().encoderConfig(encoderConfig().encodeContentTypeAs("application/vnd.ms-excel", ContentType.JSON))).
           multiPart(new MultiPartSpecBuilder(greeting)
                   .fileName("RoleBasedAccessFeaturePlan.csv")
                   .controlName("text")
                   .mimeType("application/vnd.ms-excel").build()).
    when().
           post("/multipart/text").
    then().
           statusCode(200);
  This will now serialize the "greeting" as JSON even though the mime-type is set to "application/vnd.ms-excel" (which is unknown to REST Assured) (issue 586)
* You can now pass in which ObjectMapperType or ObjectMapper to use when serializing an object using multipart. For example:
    Greeting greeting = new Greeting();
    greeting.setFirstName("John");
    greeting.setLastName("Doe");

    given().
           multiPart(new MultiPartSpecBuilder(greeting, ObjectMapperType.GSON)
                   .fileName("RoleBasedAccessFeaturePlan.csv")
                   .controlName("text")
                   .mimeType("application/vnd.ms-excel").build()).
    when().
           post("/multipart/text").
    then().
           statusCode(200);
  This will force the use if the GSON ObjectMapper (if available in the classpath) even though mime type is not recognized by default by REST Assured.
* Charset for multipart requests is now taken into account
* Content-Type for multipart requests is now taken into account. For example you can now do:
    given().contentType("multipart/mixed").multiPart(..)
  which was not possible in the previous version. (Only "multipart/form-data" worked) (issue 586)
* It's now possible to specify default mime subtype for multipart content-type. Use the MultiPartConfig#defaultSubtype(..) method.
  Default is "form-data" which results in a content-type of "multipart/form-data". This also works for the MockMvc module.
* Upgraded JUnit to 4.12
* Non-backward compatible change: Fixed so that GPath expressions using XML namespaces are evaluated from the root.
  The implementation was previously a misunderstanding of how the Groovy's XmlSlurper worked when using namespace and has now been corrected. For example let's say
  you have a service at "/namespace-example" that returns the following XML:

    <foo xmlns:ns="http://localhost/">
      <bar>sudo </bar>
      <ns:bar>make me a sandwich!</ns:bar>
    </foo>

  You NOW test it like this:

    given().
            config(newConfig().xmlConfig(xmlConfig().declareNamespace("ns", "http://localhost/"))).
    when().
            get("/namespace-example").
    then().
            body("foo.bar.text()", equalTo("sudo make me a sandwich!")).
            body(":foo.:bar.text()", equalTo("sudo ")).
            body("foo.ns:bar.text()", equalTo("make me a sandwich!"));

  In the previous versions you did like this:

    given().
            config(newConfig().xmlConfig(xmlConfig().declareNamespace("ns", "http://localhost/"))).
    when().
            get("/namespace-example").
    then().
            body("bar.text()", equalTo("sudo make me a sandwich!")).
            body(":bar.text()", equalTo("sudo ")).
            body("ns:bar.text()", equalTo("make me a sandwich!"));

  Which was not correct (notice the missing foo property)! Big thanks to Erich Eichinger for spotting this and providing a pull request (issue 592).
* Simplified setting of accept header in the MockMvc module (issue 591)
* It's now possible to use a mapping function when validating headers. For example let's say you want to validate that the Content-Length header is less than 1000.
  You can then use a mapping function to first convert the header value to an int and then use an "integer" Hamcrest matcher:
    when().get("/something").then().header("Content-Length", Integer::parseInt, lessThan(1000));
  This is also implemented for the MockMvc module (issue 594).
* Added new config called ParamConfig that allows you to configure how parameter types should be updated. By default all parameters are merged so if you do:
    given().queryParam("param1", "value1").queryParam("param1", "value2").when().get("/x"). ...
  REST Assured will send a query string of "param1=value1&param1=value2". This is not always what you want though so from now on you can configure REST Assured to replace
  values instead:
    given().
            config(config().paramConfig(paramConfig().queryParamsUpdateStrategy(REPLACE))).
            queryParam("param1", "value1").
            queryParam("param1", "value2").
    when().
            get("/x"). ..
  REST Assured will now replace "param1" with "value2" (since it's written last) instead of merging them together. You can configure the update strategy for each
  parameter type of for all parameter types:
    given().config(config().paramConfig(paramConfig().replaceAllParameters())). ..
  This is also implemented for the MockMvc module (but the config there is called MockMvcParamConfig) (issue 589)
* Non-backward compatible change: When multiple cookies or headers with the same name are returned in the response the LAST value is what's returned when
  only getting one value from the entity (Headers or Cookies) or when validating values. For example let's say that the server returns headers:
    HeaderName: Value 1
    HeaderName: Value 2
  then if you do:
    get("/x").extract().header("HeaderName")
  Value 2 will be returned (previous Value 1 would be returned).
  Likewise if you do validation:
    get("/x").then().header("HeaderName", equalTo("Value 2");
  This change also affects session ids. This is done to be compatible with the way browsers work (issue 543).
* Added ability to specify which encoder charset to use for a specific content-type if no charset is defined explicitly for this content-type.
  Previously you could only specify a default charset for ALL content-types. You do this by using the "defaultCharsetForContentType" method in the
  com.jayway.restassured.config.EncoderConfig. For example:
    RestAssured.config = config(config().encoderConfig(encoderConfig().defaultCharsetForContentType("UTF-16", "application/xml")));
  This will assume UTF-16 encoding for "application/xml" content-types that does explicitly specify a charset.
  By default "application/json" is now specified to use "UTF-8" as default content-type as this is specified by RFC4627.
  This is may be a backward incompatible change since previously "application/json" content-types
  were encoded using the platform default content-type (or what was specified by defaultContentCharset(..)) (issue 567).
* Added ability to specify which decoder charset to use for a specific content-type if no charset is defined explicitly for this content-type.
  Previously you could only specify a default charset for ALL content-types. You do this by using the "defaultCharsetForContentType" method in the
  com.jayway.restassured.config.DecoderConfig. For example:
    RestAssured.config = config(config().decoderConfig(decoderConfig().defaultCharsetForContentType("UTF-16", "application/xml")));
  This will assume UTF-16 encoding for "application/xml" content-types that does explicitly specify a charset.
  By default "application/json" is now specified to use "UTF-8" as default charset as this is specified by RFC4627.
  This is may be a backward incompatible change since previously "application/json" content-types
  were encoded using the platform default content-type (or what was specified by defaultContentCharset(..)).
* Fixed so that com.jayway.restassured.builder.ResponseBuilder register a ResponseParserRegistrar by default to avoid NPE when logging custom built responses.
* Fixed so that com.jayway.restassured.builder.ResponseBuilder now uses status code as status line if no status line was explicitly defined.
* Added ability to set a header in com.jayway.restassured.builder.ResponseBuilder.
* Setting contentType in com.jayway.restassured.builder.ResponseBuilder also sets the header.
* Added ability to pass a ContentType as argument to "setContentType" method in com.jayway.restassured.builder.ResponseBuilder.
* Added a new module called spring-support that adds an alias to the "then" method in Response or MockMvcResponse called "Then".
  The reason for this is that "then" might be a reserved keyword in Scala in the future and the compiler gives a warning when using "then".
  To enable the use of "Then" simply import the "com.jayway.restassured.module.scala.RestAssuredSupport.AddThenToResponse". For example:
    import com.jayway.restassured.RestAssured.when
    import com.jayway.restassured.module.scala.RestAssuredSupport.AddThenToResponse
    import org.hamcrest.Matchers.equalTo
    import org.junit.Test

    @Test
    def `trying out rest assured in scala with implicit conversion`() {
        when().
                get("/greetJSON").
        Then().
                statusCode(200).
                body("key", equalTo("value"))
    }
  This is also support for the spring-mock-mvc module.

Changelog 2.5.0 (2015-08-09)
-----------------------------
* MockMvc module now supports async requests. For example "given().body(..).when().async().post("/x").then(). ..". Big thanks to Marcin Grzejszczak (@mgrzejszczak) for helping out.
* Fixed NPE when using logging with a custom filter that doesn't include any headers.
* REST Assured can now resolve multiple path parameters inside the same URI "path parameter" (for example /somewhere/{x}{y}/z)
* Using non-deprecated DateUtils from Apache HTTP Client in CookieMatcher
* Quotations when extracting charset parameter is no longer required (thanks to Ronny Bräunlich for pull request)
* Content specified with a content-type starting with "text/" or containing "+text" is now automatically encoded as using the text encoder (issue 574)
* It's now possible to specify how content for a specific content-type should be serialized using com.jayway.restassured.config.EncoderConfig#encodeContentTypeAs(..).
  For example let's say that you want to serialized content-type "my-custom-content-type" as text:
  given().
          config(RestAssured.config().encoderConfig(encoderConfig().encodeContentTypeAs("my-custom-content-type", ContentType.TEXT))).
          contentType("my-custom-content-type").
          content("Some text content").
  when().
          post("/somewhere"). ..
* Improved escaping of certain attributes (such as 'properties') when parsing JSON and XML (issue 552)
* REST Assured now show all failing body assertions when using multiple expectations in the same body clause. For example:
    .. then().body("x.y", equalTo("z"), "y.z", is(2)). ..
  If both "x.y" and "y.z" fails REST Assured will print both errors. Before only the error of "x.y" was shown.
* Upgraded Groovy from 2.4.3 to 2.4.4
* Pretty-printing of JSON now displays unicode characters correctly (issue 556)
* Fixed so that the specified charset is actually used when calling com.jayway.restassured.path.json.config.JsonPathConfig#charset(String)
* Fixed so that specifying number return type in com.jayway.restassured.path.json.config.JsonPathConfig#numberReturnType(..) doesn't override the other settings
* Added new a new NumberReturnType that can be used with JsonPathConfig in order to always return non-integer numbers as doubles. This also you to for example use the "closeTo" Hamcrest matcher. For example:
  RestAssured.config = RestAssured.config().jsonConfig(jsonConfig().numberReturnType(DOUBLE));
  (issue 571)
* Upgraded optional Scribe dependency for OAuth2 authentication from version 1.3.5 to version 1.3.7.
* Possible to sign the request with an oauth2 access token (in the header) without using Scribe (issue 509)
* Non-backward compatible change: Changed com.jayway.restassured.matcher.ResponseAwareMatcher from an abstract class to a (functional) interface.
  The reason is to allow for creating ResponseAwareMatchers as lambda expressions in Java 8. Before you had to do like this (even in Java 8):
    when().
           get("/game").
    then().
           body("_links.self.href", new ResponseAwareMatcher<Response>() {
               public Matcher<?> matcher(Response response) {
                   return equalTo("http://localhost:8080/" + response.path("id"));
               }
           });
  but with the new change you can now do (if using Java 8):
    when().
           get("/game").
    then().
           body("_links.self.href", response -> equalTo("http://localhost:8080/" + response.path("id")));
  which is much less verbose. This change should be backward compatible unless you use composition of matchers. Before you composed ResponseAwareMatchers like this:
    when().
           get("/game").
    then().
           body("_links.self.href", responseAwareMatcher1.and(responseAwareMatcher2));
  This now longer works (since we cannot implement default methods in the ResponseAwareMatcher interface in order to be compatible with older Java versions)
  so now you use the new com.jayway.restassured.matcher.ResponseAwareMatcherComposer class to compose ResponseAwareMatchers instead:
    when().
           get("/game").
    then().
           body("_links.self.href", and(responseAwareMatcher1, responseAwareMatcher2));
  where "and" is statically imported from ResponseAwareMatcherComposer. These can also be nested and combined with regular Hamcrest matchers, for example:
    when().
           get("/game").
    then().
           body("_links.self.href", and(responseAwareMatcher1, containsString("something"), or(responseAwareMatcher2, responseAwareMatcher3, endsWith("x"))));
  (issue 575)
* Updated com.github.fge.json-schema-validator from version 2.2.5 to 2.2.6 in the json-schema-validator module
* Non-backward compatible change: multiPart methods taking java.io.File as argument now uses the filename of the File instead of just "file".
* Fixed a NPE when using ResponseBuilder without setting a status code.
* Multipart file uploading now supports specifying an empty filename.
* It's now possible to set default filename and control name for multiparts. Before they were always equal to "file" but this is now configurable using the new MultiPartConfig. For example:
    given().config(config().multiPartConfig(multiPartConfig().with().defaultFileName("custom1").and().defaultControlName("custom2"))). ..
  This is also implemented for the Spring Mock MVC module.
* Upgraded Spring from version 4.1.6.RELEASE to 4.2.0.RELEASE in the spring-mock-mvc module
* Upgraded Spring Security from version 3.2.5.RELEASE to 4.0.2.RELEASE in the spring-mock-mvc module
* Added support for RequestPostProcessor authentication to the Spring Mock MVC module. For example:
     given().auth().with(httpBasic("username", "password")). ..
  where "httpBasic" is statically imported from org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors. This requires that you have "spring-security-test" in your classpath.
* Added support for RequestPostProcessors to the Spring Mock MVC module, for example:
    given().postProcessors(myRequestPostProcessor1, myRequestPostProcessor2). ..
* It's now possible to supply MockMvcConfigurers when calling webAppContextSetup in the Spring Mock MVC module. For example:
    given().webAppContextSetup(context, springSecurity()). ..
* Non-backward compatible change: The field "RestAssuredMockMvc.mockMvc" has been replaced by a method: "RestAssuredMockMvc.mockMvc(..)". Before you did:
    RestAssuredMockMvc.mockMvc = myMockMvcInstance;
  but now you need to do:
    RestAssuredMockMvc.mockMvc(myMockMvcInstance);
* Added RestAssuredMockMvc#config() method that returns the assign static config or a new config if no static config has been assigned
* Spring Mock MVC module automatically registers org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurer as request post processor if spring-security-test is available in classpath.
  This means that you don't have to create a custom MockMvc instance with a "SecurityMockMvcConfigurer" manually which means easier setup.
* Added MockMvcConfig to RestAssuredMockMvcConfig which allows you to configure whether or not SecurityMockMvcConfigurer should be applied by default (default is true). To disable it use:
    given().config(config().mockMvcConfig(mockMvcConfig().dontAutomaticallyApplySpringSecurityMockMvcConfigurer())). ..
* Added ability to supply an instance of MockMvcBuilder to the standaloneSetup method in MockMvcRequestSpecification.
* Added support for standalone setup (setStandaloneSetup) and web app context setup (setWebAppContextSetup) in MockMvcRequestSpecBuilder.

Changelog 2.4.1 (2015-04-12)
----------------------------
* DefaultJackson2ObjectMapperFactory now scans and registers additional modules (issue 385)
* FilterableRequestSpecification#getPort now returns the correct port and not just -1.
* Upgraded to Groovy 2.4.3
* Upgraded Spring dependencies from 4.1.2.RELEASE to version 4.1.6.RELEASE in the Spring MockMvc module.
* REST Assured now allows specifying "File" and "InputStream" as request body.
* REST Assured MockMvc now allows specifying "File" as body.

Changelog 2.4.0 (2014-11-15)
-----------------------------
* The "matcherConfig" method in com.jayway.restassured.config.MatcherConfig is now static as intended.
* Fixed an issue in com.jayway.restassured.internal.path.xml.mapping.XmlPathJaxbObjectDeserializer that prevented parsing when XmlRootElement wasn't used.
* defaultContentCharset and defaultQueryParameterCharset in com.jayway.restassured.config.EncoderConfig now accepts a java.nio.charset.Charset as parameter (issue 363).
* com.jayway.restassured.config.DecoderConfig now accepts a java.nio.charset.Charset as parameter (issue 363).
* Content-Type expectations are now matched by using ignore case.
* Content-Type is now sent to the server if explicitly defined by a GET request (issue 362).
* Added syntactic sugar method "logRequestTo" to com.jayway.restassured.filter.log.RequestLoggingFilter as a shortcut for doing "new RequestLoggingFilter(printStream)".
* Default Content-Type charset is now visible in the request log.
* Default Content-Type charset is now appended to Content-Type header in Spring MockMvc module by default. Use "given().config(RestAssuredMockMvcConfig.config().encoderConfig(encoderConfig().appendDefaultContentCharsetToContentTypeIfUndefined(false))). .." to revert to previous behavior.
* PUT now uses content-type application/x-www-form-urlencoded by default when using form parameters.
* Content-Type is now correctly displayed in request log when not explicitly defined.
* Content-Type charset is now available in Filters when calling getRequestContentType() on the request specification.
* Deprecated RestAssured.responseContentType(..). Use com.jayway.restassured.builder.ResponseSpecBuilder#expectContentType(com.jayway.restassured.http.ContentType) and assign it to RestAssured.responseSpecification instead.
* Deprecated RestAssured.requestContentType(..). Use com.jayway.restassured.builder.RequestSpecBuilder#contentType(com.jayway.restassured.http.ContentType) and assign it to RestAssured.requestSpecification instead.
* Non-backward compatible change: Setting contentType on a ResponseSpecification no longer sets the accept header automatically. Previously this led to confusion and prevented separation between the ResponseSpecification and the RequestSpecification.
* Added "accept" method to RequestSpecification to easier allow setting the Accept header. Also added setAccept to RequestSpecBuilder.
* Added ability to configure if headers should be merged or overwritten when multiple headers with the same name are specified by using the new com.jayway.restassured.config.HeaderConfig. By default content-type and accept headers are now overwritten instead of merged. For example to configure "header1" to be overwritten instead of merged you can do:
    RequestSpecification spec = new RequestSpecBuilder.addHeader("header1", "value2").build();
    given().
            config(RestAssuredConfig.config().headerConfig(headerConfig().overwriteHeadersWithName("header1"))).
            header("header1", "value1").
            spec(spec).
    when().
            get(..)

    will only send one header, "header1" with value "value2".
* Fixed an issue in com.jayway.restassured.config.ObjectMapperConfig#defaultObjectMapperType(..) that reset state to default values.
* Added asList method to Headers to make easier to transform them to a list.
* Added method "hasSameNameAs" to com.jayway.restassured.response.Header.
* Configurations are now overwritten only if they've been explicitly configured when applying a specification. For example:
    RequestSpecification spec = new RequestSpecBuilder.config(config().headerConfig().overwriteHeadersWithName("header1")).build();

    given().
            config(config().sessionConfig(sessionConfig().sessionIdName("phpsessionid"))).
            spec(spec).
            ..
    when().
            get(..)

    This will now cause the resulting config to include both the header config and session config. Before this change ONLY header config would be applied since all configs from the specs were overwritten. This also applies to the MockMvc extension.
* Upgraded Spring version for RestAssuredMockMvc from version 4.0.6.RELEASE to 4.1.2.RELEASE.
* Upgraded Groovy from version 2.3.6 to 2.3.7.
* Upgraded commons-fileupload for RestAssuredMockMvc from version 1.2.2 to version 1.3.1.
* Upgraded httpclient from version 4.3.5 to version 4.3.6.
* It's now possible to specify the SSLContext protocol when configuring "relaxedHTTPSValidation" in SSLConfig. For example sslConfig.relaxedHTTPSValidation("TLS"). Default is SSL just as in previous versions. (issue 367).
* You can now send form parameters with a GET request in accordance with RFC1866 (page 46, HTML 4.x section 17.13.3). Form parameters will be added a query parameters for a GET request and Content-Type will automatically be set to "application/x-www-form-urlencoded" with the default charset.
* Added ability to log request method and request path. Use "given().log().method()" and "given().log().path()" (issue 368).

Changelog 2.3.4 (2014-10-06)
-----------------------------
* XmlXsdMatcher#matchesXsdInClasspath(..) now returns an instance of XmlXsdMatcher so that you can easily set a LSResourceResolver.
* ObjectMapperResolver looks for third party libraries in both thread context- and ObjectMapperResolver classloader.
* It's now possible to configure the way error messages are generated in REST Assured using the com.jayway.restassured.config.MatcherConfig. For example:
    given().config(RestAssured.config().matcherConfig(new MatcherConfig(HAMCREST))). ..
  will generate error messages that are close to original Hamcrest messages. The other option is REST_ASSURED which uses the default error messages generated by REST Assured.
* Made it possible to configure whether to automatically append charset to content-type for all content types using the EncoderConfig (issue 355).
* Deprecated "appendDefaultContentCharsetToStreamingContentTypeIfUndefined" in EncoderConfig. Just use "appendDefaultContentCharsetToContentTypeIfUndefined" instead.
* Added ability to remove parameters from a request specification using the RequestSpecBuilder (thanks to Merkushev Kirill for the help).
* Fully-qualified baseUris will no longer have to use explicit port 80 (issue 353)

Changelog 2.3.3 (2014-08-29)
----------------------------
* Added CSRF (cross-site request forgery) support to form authentication config. For example:
    given().
            auth().form("John", "Doe", formAuthConfig().withAutoDetectionOfCsrf()).
    when().
            get("/formAuthCsrf");
  This example tries to find the field specifying the CSRF token automatically but it's also possible to define it:
    given(). auth().form("John", "Doe", formAuthConfig().withCsrfFieldName("_csrf")). ..
  Note that REST Assured must always make an additional request to the server if enabling CSRF support.
* com.jayway.restassured.internal.print.ResponsePrinter now returns the entire response (including headers, parameters etc) and not just the body.
* Fixed so that all parameters are taken into account in RequestSpecBuilder when adding a multi-part with the controlName, contentBody, mimeType signature (issue 343).
* Upgraded Spring version for RestAssuredMockMvc from version 4.0.5.RELEASE to 4.0.6.RELEASE.
* Upgraded Spring Security optional dependency from version 3.2.0 to 3.2.5.RELEASE.
* Upgraded faster Jackson optional dependency from version 2.4.0 to 2.4.2.
* Upgraded commons-lang3 from version 3.1 to 3.3.2.
* Upgraded Groovy from version 2.3.2 to 2.3.6.
* Upgraded Http Client from version 4.2.6 to 4.3.5.
* Made it possible to configure whether to automatically append charset to content-type for streaming content using the EncoderConfig (issue 345).
* Support for request attributes in spring-mock-mvc (thanks to Jacek Kunicki for the pull request)
* JsonSchemaValidator no longer parse URI's and URL's as JsonNode's by default since prevented resolving relative $ref in a parent schema. This is configurable using the JsonSchemaValidatorSettings (issue 346).
* Fixed so that request and response is logged when "enableLoggingOfRequestAndResponseIfValidationFails" is defined when a response specifications fails to validate (issue 350).
* Fixed so that multi-part file data uploading works for files without specifying an explicit filename when using HTTP Client version 4.3 and above (issue 351).

Changelog 2.3.2 (2014-06-09)
-----------------------------
* Fixed an issue with logging of request and response using RestAssured.enableLoggingOfRequestAndResponseIfValidationFails() for certain validations.
* Fixed issue with content-type validation when no content-type was sent from the server.
* Updated Groovy to version 2.3.2
* Widen the standaloneSetup builder method in Spring MVC module to accept a AbstractMockMvcBuilder (issue 321).
* Added possibility to include parameters in JsonPath and XmlPath to prevent injection weaknesses (issue 328).
* Added "matchesXsdFromClasspath" to com.jayway.restassured.matcher.RestAssuredMatchers and com.jayway.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers (issue 330).
* Added "matchesDtdFromClasspath" to com.jayway.restassured.matcher.RestAssuredMatchers and com.jayway.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers (issue 331).
* Upgraded Spring MVC module to depend on Spring 4.0.5. (issue 335)
* Added possibility to use "no wrap" for response streams of type gzdeflate (RFC 1951) used by e.g. PHP. Usage example: given().config(config().decoderConfig(decoderConfig().useNoWrapForInflateDecoding(true))).when().get("/x"). (issue 327).
* basePath can now be set in the RequestSpecification as well as RequestSpecBuilder (issue 325).
* Static usage of "enableLoggingOfRequestAndResponseIfValidationFails" can now be assigned after static request and response configurations (issue 323).
* Multipart parameters are now logged when logging the request specification (issue 144).
* Added ability to get multipart parameters from com.jayway.restassured.specification.FilterableRequestSpecification using the "getMultiPartParams" method.
* Added "replaceFiltersWith" method to RestAssured which makes it possible to replace statically defined filters (issue 174).
* Added support for specifying arguments to root or append paths at a later stage, for example:
    when().
         get("/jsonStore").
    then().
         root("store.%s", withArgs("book")).
         body("category.size()", equalTo(4)).
         appendRoot("%s.%s", withArgs("author")).
         body(withArgs("size()"), equalTo(4)); // The last argument defined in "appendRoot" is applied here
 (issue 267).
* Added ability to log the request and response generated by the form authentication scheme, for example:
    given().
            auth().form("John", "Doe", springSecurity().withLoggingEnabled()).
    when().
            get("/formAuth").
    then().
            statusCode(200).
            body(equalTo("OK"));
  (issue 274).
* Fixed so that CharsetExtractor no longer fails to extract the charset when more than one key=value pair present in the content-type header (issue 337).
* Updated json-schema-validator module to use version 2.2.5 of FGE's json schema validator project.
* Updated commons-lang3 dependency to version 3.3.2.
* Added static compilation to inner class PathType to avoid IncompatibleClassChangeError because of a bug in Groovy (GROOVY-6080) (issue 336).
* Added better proxy support. For example:
    given().proxy("localhost", 8888). ..
  or for all requests:
    RestAssured.proxy("localhost", 8888);
    RestAssured.proxy = host("localhost").withPort(8888); // "host" is statically imported from com.jayway.restassured.specification.ProxySpecification.
  or using a RequestSpecification:
    RequestSpecification specification = new RequestSpecBuilder().setProxy("localhost").build();
    given().spec(specification). ..
  The proxy details are also visible in the request log and are available from the com.jayway.restassured.specification.FilterableRequestSpecification.
  (issue 214).

Changelog 2.3.1 (2014-03-31)
-----------------------------
* Fixed a bug where fully-qualified URLs showed up as localhost in the request path in logging (issue 304).
* Fixed a NPE when parsing no-value cookies in HTTP response (issue 306).
* Query params and values now splits the '=' with max count 2 (issue 305).
* Added support for HttpOnly cookies (thanks to Luke Bunselmeyer for pull request).
* Added support for specifying properties in XmlConfig and XmlPathConfig.
* Updated json-schema-validator module to use version 2.1.8 of FGE's json schema validator project.
* Fixed bug where query parameters with an empty value are no longer treated as query parameters without a value (issue 314).
* Fixed issue where response could not be created using the ResponseBuilder if using the given-when-then syntax.
* It's now possible to supply a resource resolver when matching XSD. For example:
    get("/x").then().body(matchesXsd(load("main.xsd")).using(new ClasspathResourceResolver()));
  (issue 317).
* Upgraded Spring MVC module to depend on Spring 4.0.3.RELEASE.
* Fixed a bug with JsonPath that prevented parsing of JSON attributes starting with a number (issue 318).
* Added appendRootPath method to ResponseSpecBuilder
* Added noRootPath method to ResponseSpecBuilder
* Added detachRoot method to ResponseSpecification that allows you to detach parts of the root paths (issue 319).
* Added detachRootPath method to ResponseSpecBuilder.
* "appendRoot" method in ResponseSpecification can now be used even though no root path has previously been set.
* Added a RestAssuredMockMvc.standaloneSetup(DefaultMockMvcBuilder) method in order to allow more flexible customization of the spring context (thanks to Martin Ahrer for the pull request) (issue 321).
* Added static "with" method to RestAssuredMockMvc that can be used instead of "given" if needed (issue 320).
* Added support for logging the request specification or response specification if the test validation fails. For example:
    given().log().ifValidationFails(). ..
  will log the request only if REST Assured's validations fail. It's also applicable for the response. This works in both vanilla REST Assured and REST Assured Mock Mvc (issue 212).
* Added support for logging both the request specification and response specification if the test validation fails. For example:
    RestAssured.config = RestAssured.config().logConfig(logConfig().enableLoggingOfRequestAndResponseIfValidationFails());
  There's also a shortcut for this:
    RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
  This has also been implemented in RestAssuredMockMvc (issue 212).
* Fixed so that pretty logging of the response body doesn't change the body returned to the matchers.
* Fixed so that it's possible to log data with charset binary.
* Getting a String from the response now stores the content as a byte-array internally to avoid messing up binary content.
* Added tagsoup as transitive dependency to XmlPath so that it's easier to get started with HTML parsing (issue 311).

Changelog 2.3.0 (2014-01-23)
-----------------------------
* Fixed an IllegalArgumentException with reusable response specifications when defined before other body expectations when using the given-when-then API.
* Non-backward compatible change: The json-path module accidentally depended on faster-jackson, jackson, gson and simple-json and brought then in as transitive dependencies. This has now been resolved which means that these dependencies are optional as intended (issue 297).
* Fixed serious issues with SSL config and certificate authentication. A TrustStore as accidentally used as a KeyStore which caused errors like: "sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target".
* Added support for adding a SSLSocketFactory to SSLConfig (issue 170).
* RestAssuredMockMvc is now using "/" as default basePath so that you can use non-arg HTTP methods (such as get()) without first defining a basePath (issue 296).
* Add static "when" method to RestAssuredMockMvc (issue 295).
* Added support for specifying a trust store, either using the DSL using given().trustStore(..), or statically using RestAssured.trustStore(..) (issue 299).
* Added support for relaxed https validation. This means that you'll trust all hosts regardless if the SSL certificate is invalid. By using this you don't need to specify a keystore or trust store. For example:
    given().relaxedHTTPSValidation().when().get("https://some-url-with-invalid-cert.com"). ..
  You can also define it statically for all requests:
    RestAssured.useRelaxedHTTPValidation();
  (issue 298)
* Added support for authentication in RestAssuredMockMvc. You can now do e.g. given().auth().principal(..). Some auth methods require Spring Security to be on the classpath (optional). It's also possible to defined authentication statically:
    RestAssuredMockMvc.authentication = principal("username", "password");
  where the "principal" method is statically imported from RestAssuredMockMvc. It's also possible to define an authentication scheme in a request builder:
    MockMvcRequestSpecification spec = new MockMvcRequestSpecBuilder.setAuth(principal("username", "password")).build();
* Non-backward compatible change: Statically defined configuration (such as RestAssured.config = ..) is now automatically applied to RequestSpecBuilders in both RestAssured and RestAssuredMockMvc. To revert to previous behavior you can do
    new RequestSpecBuilder.config(newConfig()). ..
* Updated Groovy dependency to 2.2.1.
* MockMvcResponse now allows you to extract the MvcResult and MockHttpServletResponse (issue 294).
* Added support for using parts of the response when verifying the response. For example consider the following JSON document returned from service x:
    { "userId" : "some-id", "href" : "http://localhost:8080/some-id" }
  You may notice that the "href" attribute ends with the value of the "userId" attribute. If we want to verify this we can implement a com.jayway.restassured.matcher.ResponseAwareMatcher and use it like this:
    get("/x").then().body("href", new ResponseAwareMatcher<Response>() {
                                        public Matcher<?> matcher(Response response) {
                                              return equalTo("http://localhost:8080/" + response.path("userId"));
                                        }
                                  });
  There are some predefined matchers that you can use defined in the com.jayway.restassured.matcher.RestAssuredMatchers (or com.jayway.restassured.module.mockmvc.matcher.RestAssuredMockMvcMatchers if using the spring-mock-mvc module). For example:
    get("/x").then().body("href", endsWithPath("userId"));
  (issue 288).
* Fixed NPE in RestAssuredMockMvc when path is null.

Changelog 2.2.0 (2014-01-08)
-----------------------------
* Fixed an issue with content-type identification when passing in content-type header manually using a header.
* Header values supplied to request specification using a java.util.Map are now serialized if needed.
* Path parameters can now be used in the entire path, not just between two slashes (issue 275, 292).
* Added ability to set logging from the RequestSpecBuilder, for example new RequestSpecBuilder().log(ALL).build();
* Response specifications are now validated correctly when passed to spec or specification method after then is called. For example:
    ResponseSpecification specification = new ResponseSpecBuilder().expectStatusCode(200).expectBody("greeting", equalTo("Greetings John Doe")).build();
    given().
            param("firstName", "John").
            param("lastName", "Doe").
    when().
            get("/greet").
    then().
            spec(specification);
* REST Assured now supports OAuth2 authentication using the Scribe framework (https://github.com/fernandezpablo85/scribe-java). Big thanks to Waseem Shaik for all the help!
* Non-backward compatible change: REST Assured now use the Scribe framework (https://github.com/fernandezpablo85/scribe-java) instead of Signpost for oauth1 authentication so you need to update your classpath dependencies. Please read the release notes for more info.
* Added Spring Mock Mvc (Spring test) module which let's you unit test Spring MVC controllers using the REST Assured DSL. Depend on artifact id "spring-mock-mvc" using group id "com.jayway.restassured" from Maven to use it. Then use RestAssuredMockMvc to get started.
* Fixed so that RestAssured.given(requestSpecification) now merges the static request specification correctly.

Changelog 2.1.0 (2013-12-09)
-----------------------------
* Changed the way REST Assured finds key stores in classpath. It now uses thread context classloader to resolve the files instead of the class KeyStoreSpecImpl classloader.
  This means means that you're able to do e.g. "RestAssured.keystore("keystore.jks", "test1234")" where you before used "RestAssured.keystore("/keystore.jks", "test1234")".
* java.util.UUID is now serialized as a String (issue 285).
* Non-backward compatible change: It's no longer possible to assert that an empty response object has a path that is null, for example let's say that the "/statusCode409WithNoBody" resource returns an empty body:
    expect().contentType(ContentType.JSON).body("error", equalTo(null)).when().get("/statusCode409WithNoBody"); // This will now throw assertion error
* Added support to for mixing text and path assertions. For example:
    get("/lotto").then().body(containsString("\"numbers\":[52")).and().body("lotto.winners.winnerId", hasItems(23, 54));
* Non-backward compatible change: Changed default response content charset from ISO-8859-1 to system default charset. The reason for this that most users would probably expect the system default charset. To change the behavior use the DecoderConfig (issue 283).
* Non-backward compatible change: Changed default request content charset from ISO-8859-1 to system default charset. The reason for this that most users would probably expect the system default charset. To change the behavior use the EncoderConfig (issue 283).
* REST Assured now supports JSON schema validation (http://json-schema.org/). To allow for this you need to add the json schema validator module to classpath. Once you done that you should statically import "com.jayway.restassured.module.jsv.JsonSchemaValidator.*" and then you can do e.g.
    get("/products").then().assertThat().body(matchesJsonSchemaInClasspath("products-schema.json"));
  (issue 284)
* Non-backward compatible change: Removed the following method from the RestAssured API: "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider, boolean checkServerHostname)" and "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider)".
* Deprecated the following method from the RestAssured API: "certificate(String certURL, String password, String certType, int port)", "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider, boolean checkServerHostname)". It's replaced by the "certificate(String certURL, String password, CertificateAuthSettings certificateAuthSettings)" method. For example:
    RestAssured.authentication = certificate(certUrl, password, certAuthSettings().with().port(435));
* Non-backward compatible change: Removed the following method from the AuthenticationSpecification API: "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider, boolean checkServerHostname)" and "certificate(String certURL, String password, String certType, int port, KeystoreProvider trustStoreProvider)".
* Deprecated the following method from the AuthenticationSpecification API: "certificate(String certURL, String password, String certType, int port)". It's replaced by the "certificate(String certURL, String password, CertificateAuthSettings certificateAuthSettings)" method. For example:
    given().auth().certificate(certUrl, password, certAuthSettings().with().port(435)). ..
* Added support for disabling hostname verification by disabling this using the CertificateAuthSettings:
    given().auth().certificate(certUrl, password, certAuthSettings().with().allowAllHostnames(). ..
  (issue 182)
* Non-backward compatible change: Removed static method "RestAssured.keystore()". You can now get the keystore settings from the SSL configuration instead.
* Non-backward compatible change: Removed the com.jayway.restassured.authentication.KeyStoreProvider interface. The KeyStoreProvider was actually NOT used to create a KeyStore but rather a trust store. To specify the trust store after this change use the SSLConfig or certificate authentication.
* Non-backward compatible change: All keystore related methods in the RestAssured API now returns void instead of KeyStoreSpec.
* You can now get the current REST Assured configuration by calling RestAssured.config()
* Non-backward compatible change: Removed method "RestAssured.keyStore()". If you want to get the configured "keystore" configuration you can now call "RestAssured.config().getSSLConfig();".

Changelog 2.0.1 (2013-11-29)
-----------------------------
* Fixed an issue which prevented extracting data from a response after body assertions had been used.

Changelog 2.0.0 (2013-11-29)
-----------------------------
* Fixed a regression bug where Rest Assured didn't respected trailing slashes in URL's (issue 276).
* Fixed so that the path method in the Response can be invoked multiple times, for example:
    Response response = get("/jsonStore");
    float minPrice = response.path("store.book.price.min()");
    float maxPrice = response.path("store.book.price.max()");
  (issue 280)
* Fixed so that JsonPath and XmlPath and path expressions work after the "prettyPrint" and "print" methods have been called on a Response instance.
* Added support for performing requests with URI's and URL's, for example:
    URI myUri = new URI(..)
    Response response = get(myUri);
  (issue 278)
* Added possibility to call request methods without any parameters. This is useful if you want to call the root resource. For example:
    RestAssured.baseURI = "http://localhost:8080/hello";
    String y = get().path("x.y");
  (issue 279)
* It's now possible to call asString() on a Response object after asByteArray() has been called and vice versa.
* given(requestSpecification) now returns the RequestSpecification instead of RequestSender
* Added support for given-when-then syntax, for example:
      given().
              param("firstName", "John").
              param("lastName", "Doe").
      when().
              get("/greet").
      then().
              statusCode(200).
              body("greeting", equalTo("Greetings John Doe"));
* Added peek and prettyPeek support to com.jayway.restassured.response.Response which allows you to print the response to system out but continue working with the Response instance afterwards.
* Fixed a bug with RequestSpecBuilder that merged two too many cookies and headers when defined statically (issue 281).
* Fixed a bug with ResponseSpecBuilder that didn't merge certain properties correctly.
* Added static method "when" to com.jayway.restassured.RestAssured that allows you to write specifications without use of parameters, headers etc. For example:
      when().
             get("/x").
      then().
             body("x.y.z1", equalTo("Z1")).
             body("x.y.z2", equalTo("Z2"));
* Added support for arguments when calling path("..") on a Response object, for example:
      String z = get("/x").path("x.y.%s", "z");

Changelog 1.9.0 (2013-11-25)
-----------------------------
* It's now possible to validate if the ResponseSpecification is fulfilled by calling the validate method and passing in a Response object (thanks to Ian Forsey for the patch).
* Getting cookies as a Map now returns the last value returned instead of the first one if multiple cookies with the same name are sent from the server to comply with the HTTP specification (thanks to DeviKiran Setti for the patch) (issue 257).
* Fixed an issue with merging session ids when merging request specifications.
* Fixed an issue with merging baseUri and port when merging request specifications.
* Added ability to set base uri on the RequestSpecBuilder (issue 252).
* CookieMatcher initialized cookie version with -1 if value was "0" (thanks to Sergey Podgurskiy for the patch)
* Fixed stackoverflow in certificate authentication (issue 262) (thanks to douglasdedo for the patch)
* It's now possible to configure the HTTP Client instance to be used by REST Assured when making requests. Use the HttpClientConfig and specify a http client factory if you want to do this. This makes it possible for some advanced configuration not exposed by the REST Assured API (issue 203).
* Request filters now expose the http client instance which makes it possible to alter some advanced settings not exposed by REST Assured.
* The xmlPath method in the REST Assured response (com.jayway.restassured.response.Response) now accepts a CompatibilityMode. This means that it's easy to get values from HTML responses:
      String pageTitle = get("/index.html").xmlPath(CompatibilityMode.HTML).getString("html.head.title");
  (issue 258)
* Fixed a NPE when trying to parse an empty JSON response (issue 260).
* Added ability to set base uri from RequestSpecBuilder (issue 252).
* Fixed a bug where RequestSpecification was not checked against the correct type when merging request specifications.
* Fixed a bug with pretty printing that sometimes didn't take user supplied value into account.
* It's now possible to configure content decoders. Before GZIP and DEFLATE were always activated and there was no way to disable them. It's now possible to configure which to use, for example to remove GZIP but retain DEFLATE you can do the following:
	  given().config(newConfig().decoderConfig(decoderConfig().contentDecoders(DEFLATE))). ..
  (issue 77)
* The http client instance can now be reused between REST Assured requests. By default REST Assured creates a new instance for each "given" statement. To configure reuse do the following:
      RestAssured.config = newConfig().httpClient(httpClientConfig().reuseHttpClientInstance());
* Added support for appending a root path to an existing root path using "appendRoot" on the RequestSpecification, see javadoc for more info. (issue 248).
* Added support for resetting an already defined root by using "noRoot" on the RequestSpecification, see javadoc for more info. (issue 248).
* Added the "given(requestSpecification)" method to the RestAssured API (issue 56).
* Added support for body expectations with empty path and only arguments, for example expect().root("x.y.%s").body(withArgs("z"), equalTo("w")). .. (issue 265)
* Added support for body expectations without any arguments using withNoArgs() or withNoArguments, for example:
      expect().
               root("store.%s", withArgs("book")).
               body("category.size()", equalTo(4)).
               appendRoot("%s.%s", withArgs("author", "size()")).
               body(withNoArgs(), equalTo(4)).
      when().
               get("/jsonStore");
  (issue 266)
* Added method "htmlPath" to REST Assured Response which allows you to easily get values from an HTML page:
      String pageTitle = get("/index.html").htmlPath().getString("html.head.title");
  (issue 268)
* Fixed an issue where a static preemptive basic authentication couldn't be overridden by instance authentication (issue 233).
* Fixed an issue where multi-valued query parameters defined in the URL now works. For example get("/x?y=1&y=2") (issue 169, 219).
* Improved request logging so that query parameters are included in the complete path.
* Allow URLs that contains double slashes, for example get("/x/y/http://localhost:8080")
* URL encoding (and disabling of URL encoding) has been completely re-written and will now work better (issue 181).
* Fixed issues that made an incorrect port being used under certain conditions (issue 217).
* Fixed so that Hamcrest's hasXPath() and not() can be combined (issue 215).
* Fixed a bug in XmlPathConfig when setting charset.
* It's now possible to use the Hamcrest XPath matcher with namespaces if XmlConfig in REST Assured is configured to be namespace aware, e.g.
      given().
              config(newConfig().xmlConfig(xmlConfig().with().namespaceAware(true))).
      expect().
              body(hasXPath("/db:package-database", namespaceContext)).
      when().
              get("/package-db-xml");
  (issue 39)
* Added possibility to add features to the javax.xml.parsers.DocumentBuilderFactory instance used by REST Assured when parsing XML for XPath validation. Use the XmlConfig to add achieve this.
* Namespaces are now included when pretty printing or logging XML.
* Added namespace support for body expectations if the namespace is declared correctly, for example given the following XML:
      <foo xmlns:ns="http://localhost/">
         <bar>sudo </bar>
         <ns:bar>make me a sandwich!</ns:bar>
      </foo>
  you can verify it like this:
      given().
              config(newConfig().xmlConfig(xmlConfig().declareNamespace("ns", "http://localhost/"))).
      expect().
              body("bar.text()", equalTo("sudo make me a sandwich!")).
              body(":bar.text()", equalTo("sudo ")).
              body("ns:bar.text()", equalTo("make me a sandwich!")).
      when().
              get("/namespace-example");
  (issue 39)
* XmlPath returned from REST Assured Response now takes features, namespaces, charset etc into account.
* XmlPathConfig supports declaring namespaces which means that XmlPath is now namespace aware if needed.
* Added ability to supply an XmlPathConfig instance when using the xmlPath() method from a REST Assured Response object. For example :
      XmlPath xmlPath = get("/namespace-example").xmlPath(xmlPathConfig().with().declaredNamespace("ns", "http://localhost/"));
* Non-backward compatible change: RestAssuredConfig no longer accepts a JsonPathConfig, it now uses a JsonConfig object instead.
* Added ability to supply a JsonPathConfig instance when using the jsonPath() method from a REST Assured Response object. For example :
      JsonPath jsonPath = get("/namespace-example").jsonPath(jsonPathConfig().with().numberReturnType(BIG_DECIMAL));
* Added peek and prettyPeek support to XmlPath which allows you to print the content to system out but continue working with XmlPath afterwards (issue 271).
* Added peek and prettyPeek support to JsonPath which allows you to print the content to system out but continue working with JsonPath afterwards (issue 272).
* FormAuthFilter is now added first to the filter chain.
* Added hasValue(..) method to com.jayway.restassured.filter.FilterContext.
* Added support for sessions by applying the com.jayway.restassured.filter.session.SessionFilter, for example:
      SessionFilter sessionFilter = new SessionFilter();

      given().
              auth().form("John", "Doe").
              filter(sessionFilter).
      expect().
              statusCode(200).
      when().
              get("/formAuth");

      given().
              filter(sessionFilter). // Reuse the same session filter instance to automatically apply the session id from the previous response
      expect().
              statusCode(200).
      when().
              get("/formAuth");
  (issue 229, 273)
* Upgraded to Groovy 2.2.0
* Upgraded to Http Client 4.2.6
* Upgraded to Hamcrest 1.3 (issue 186)

Changelog 1.8.1 (2013-06-07)
-----------------------------
* It's now possible to configure the HTTP Multipart mode when sending multi-parts. Configure this in the REST Assured HttpClientConfig (issue 223).
* Non-backward compatible change: Default multi-part mode for multi-part uploads is changed from Browser Compatibility mode to Strict mode.
* Fixed so that getting a single detailed cookie from the Response really works.
* You can now specify a charset more easily when using com.jayway.restassured.http.Charset. For example Charset.JSON.withCharset("UTF-8") (issue 228).
* It's now possible to specify a truststore when doing certificate authentication (thanks to Ian Forsey for the help) (issue 205). Usage:
  given().auth().certificate("file:///my/project/src/test/resources/soapui.p12",  "password", "pkcs12", 8443, truststoreProvider)
* Pretty printing in JsonPath now works for json elements represented as a Java Map (issue 218).
* Reserved Groovy keyword "properties" is automatically escaped in JsonPath (issue 231).
* Response body logger now uses ": " instead of "=" when logging headers to mimic HTTP specification (issue 227).
* Added com.jayway.restassured.builder.MultiPartSpecBuilder that can be used to build more advanced multi-part requests in a fluent way. This also allows you to specify charset for strings in multi-part uploads which was previously not possible (issue 239).
* Added support for setting features in XmlPath using the XmlPathConfig. This can be used to for example disabling external DTD loading. There's also a shortcut for this by using the XmlPathConfig#disableLoadingOfExternalDtd() method (issue 237).

Changelog 1.8.0 (2013-04-01)
-----------------------------
* Added support for settings a custom Jackson 2 object factory to JsonPath
* Expecting content type to be a pre-defined content type (such as ContentType.XML) now accepts many kinds of different variations (thanks to exsuscito for the help) (issue 213).
* Upgraded to Groovy 2.1.2
* It's now possible to configure JsonPath with various settings so as returning a BigDecimal instead of floats and doubles. You can do this either statically using:
	  JsonPath.config = new JsonPathConfig(..);
  or per instance:
	  new JsonPath().using(new JsonPathConfig(..)).get(..);
* It's now possible to configure REST Assured to return BigDecimal instead of floats and doubles. You can do this either statically using:
	  RestAssured.config = new RestAssuredConfig().jsonPathConfig(new JsonPathConfig(..));
* Added support for automatically converting a String to BigDecimal in JsonPath
* Non-backward compatible change: com.jayway.restassured.exception.ParsePathException was renamed to com.jayway.restassured.exception.PathException.
* Non-backward compatible change: JsonPath now throws JsonPathException instead of Groovy's JsonException when parsing invalid JSON documents
* Non-backward compatible change: XmlPath now throws XmlPathException instead of PathException when parsing invalid XML documents
* Non-backward compatible change: ObjectMapperDeserializationContext#getResponse() has been renamed to "getDataToDeserialize()". It no longer returns an instance of ResponseBodyData, it now returns an instance of "DataToDeserialize".
* Improved error messages in XmlPath
* Added getPath method to Node and NodeChildren elements in XmlPath which allows you get a subpath using the GPath notation.
* Improved speed of JsonPath when parsing multiple values
* JsonPath and XmlPath has been extracted to their own projects. This means that you can use them with the need to depend on REST Assured.
* Major improvements to XmlPath
* Possible to configure JsonPath and XmlPath both per instance and statically.

Changelog 1.7.2 (2012-12-15)
-----------------------------
* StreamVerifier prints better error message when the response content-type is not recognized.
* REST Assured now prints all validation errors in a single test run (issue 207).
* Throws IllegalStateException when incorrectly trying to configure logging on a ResponseSpecBuilder instance after it has been built.

Changelog 1.7.1 (2012-11-11)
-----------------------------
* Added methods object variants of setBody and setContent to RequestSpecBuilder.
* Fixed so that form authentication can be added from RequestSpecBuilder.
* You can now add non-string values in form parameters (such as primitives and enums) (issue 201).
* Fixed a bug that accidentally used the content-type as character encoding on object serialization (issue 204).

Changelog 1.7 (2012-10-11)
---------------------------
* Fixed an issue with XmlPath when parsing xml attributes and using findAll.
* REST Assured now (finally) builds from Maven 3
* Explicitly registered custom parsers have precedence over default parsers (issue 183).
* It's now possible to manually set the content-type header, e.g. header("content-type", "something") now works (issue 155).
* It's now possible to create custom object mappers and configure existing ones (issue 122).
* It's now possible to define a default object mapper using the com.jayway.restassured.config.ObjectMapperConfig (issue 123).
* ObjectMapper.JACKSON, ObjectMapper.GSON and ObjectMapper.JAXB have been deprecated. Use the corresponding types in enum com.jayway.restassured.internal.mapper.ObjectMapperType instead.
* Added object mapping support for Jackson 2.0 (issue 189).
* Fixed an issue with the com.jayway.restassured.builder.ResponseBuilder that failed to clone the ResponseParserRegistrar.
* JSON path with digits separated by dots can now be processed by JsonPath (issue 195).
* Default filters accumulate and are not merged when reusing request specs (issue 197).
* Fixed so that it's possible to download large (chunked) files again. This was broken in the last release, 1.6.2. (issue 194).
* Added a ConnectionConfig (com.jayway.restassured.config.ConnectionConfig) object that allows you to modify if REST Assured should drop idle connections after each response. Enable connection dropping if you need to make several small and fast requests (e.g. stress testing).
* Path parameters are no longer url encoded if REST Assured url encoding is disabled (issue 181).
* Base path is now shown correctly in request logging when path is a fully qualified URL (issue 145).
* Updated HTTP Client version to 4.2.1.
* Added support for PATCH and OPTIONS requests (issue 164).

Changelog 1.6.2 (2012-05-28)
-----------------------------
* You can now use all kinds of Collection instances (and not only List's as in the previous versions) as multi-value parameters (issue 165).
* The specified content-type header is no longer ignored when specifying binary request body content (issue 167).
* REST Assured now closes the HTTP Client connection after each invocation (issue 168).
* JsonPath can now parse JSON documents with attribute names including dots and minus at the same time, e.g.
  	{ "a-b"  : "minus" , "a.b" : "dot"  , "a.b-c" : "both"  }"
  we can now get the result from "a.b-c" using:
        from(json).get("'a.b-c'"); // Returns "both"
  (issue 172).
* Fixed a NPE when getting the session id when no cookies were defined (issue 173).
* You can now serialize Java objects to JSON and XML in multi-part bodies. E.g.
       given().multiPart("controlName", myJavaObject, "application/json"). ..
  will serialize "myJavaObject" to a JSON string automatically (issue 166).
* Fixed a bug that prevented using a single named path parameter multiple times. I.e. this will now work:
	given().
                pathParam("firstName", "John").
        expect().
                body("fullName", equalTo("John John")).
        when().
                get("/{firstName}/{firstName}");
  (issue 169).
* Fixed an issue with RestAssured.urlEncodingEnabled which didn't take request parameters into account when url encoding was disabled (issue 175).

Changelog 1.6.1 (2012-04-05)
-----------------------------
* Default encoder is set to binary instead of url encoded. This means that when setting a binary body with an (by REST Assured) unrecognized content-type it will automatically be treated as an octet stream.
* Closed input stream when getting response body as byte-array (issue 163)
* Improved session support. You can now define a session id value in the DSL:
    given().sessionId("1234"). ..
  or for each request:
    RestAssured.sessionId = "1234";
  By default the session id name is JSESSIONID but you can change it using the SessionConfig:
    RestAssured.config = newConfig().sessionConfig(new SessionConfig().sessionIdName("phpsessionid"));
  RequestSpecBuilder has been improved to support session id's as well (issue 28).
* Added methods to the RequestSpecBuilder to enable adding cookies of type com.jayway.restassured.response.Cookie and com.jayway.restassured.response.Cookies.
* JRE proxy settings are now applied by default (thanks to Wolfram Kroll for the patch).

Changelog 1.6 (2012-02-18)
---------------------------
* Forked HTTPBuilder. This means that a lot of workarounds that had to be made in the past can be removed in the future. It also means that the Groovy version is updated to version 1.8 and HTML parsing is greatly improved as well as many other minor changes and improvements (issue 112).
* The HTTP Delete method now supports a method body
* PUT request now work for multi part form data uploading
* Added support for pretty-printing the request and response body when logging if content-type is XML, JSON or HTML. Pretty-printing is enabled by default but it could be disabled either by:
	RestAssured.config = config().logConfig(logConfig().enablePrettyPrinting(false));
  or using the DSL:
	expect().log.all(false). ..
  You can also pretty-print the response from the Response object:
	get("/some-xml").prettyPrint();
  (issue 140)
* Fixed a serious issue with content-type validation, it was actually ignored in the previous versions (issue 146).
* XmlPath supports prettifying and pretty-printing XML and HTML, for example:
	String prettyXml = with(someXml).prettify(); // Return a prettified XML string.
  or print the XML to System.out and then return it:
        String prettyXml = with(someXml).prettyPrint(); // Prints and returns a prettified XML string.
  "with" is statically imported from com.jayway.restassured.path.xml.XmlPath (issue 147).
* JsonPath supports prettifying and pretty-printing JSON documents, for example:
	String prettyJson = with(someJson).prettify(); // Return a prettified JSON string.
  or print the JSON to System.out and then return it:
        String prettyJson = with(someJson).prettyPrint(); // Prints and returns a prettified JSON string.
  "with" is statically imported from com.jayway.restassured.path.json.JsonPath (issue 147).
* REST Assured now automatically detects content-types ending with +xml, +json and +html (for example application/something+json) and parses the content with the corresponding parser. This means that you don't need to register custom parsers for these kind of content-types (issue 142).
* Added support for using "bracket notation" for parsing unnamed JSON root arrays. For example consider the following JSON document:
	[{"email":"name1@mail.com","alias":"name one","phone":"3456789"},
         {"email":"name2@mail.com","alias":"name two","phone":"1234567"},
	 {"email":"name3@mail.com","alias":"name three","phone":"2345678"}]
  and let's say you want to get the first e-mail. You can now do like this:
	String email = from(jsonDocument).getString("[0].email");
  (issue 148).
* Response cookies are no longer automatically set in subsequent requests by default. To re-enable this set the "http.protocol.cookie-policy" parameter in the HttpClientConfig to CookiePolicy.RFC_2109 (issue 149).
* Implemented support for no-value parameters, for example:
	given().queryParam("someParameterName").when().get("/something");
  This works for both "request parameters", query parameters and form parameters. (issue 143)
* Added support for getting integer JSON types without escaping, e.g. {"0":"value"} can now be parsed as ..body("0", equalTo("value"). (issue 150)
* REST Assured now takes the charset into consideration for both the request and the response. E.g.
	given().contentType("application/xml; charset=US-ASCII").and().body("my body"). .. will encode the body as US-ASCII.
  you can also specify the default charset for each request:
	RestAssured.config = newConfig().encoderConfig(encoderConfig().defaultContentCharset("US-ASCII"));
  (issue 132)
* Default content encoding charset has been changed from UTF-8 to ISO-8859-1 to comply with the RFC 2616. To change this use the EncoderConfig, e.g.
	RestAssured.config = newConfig().encoderConfig(encoderConfig().defaultContentCharset("UTF-8"));
  You can also specify the default query parameter charset.
* Default decoding content charset has been changed from platform default to ISO-8859-1 to comply with the RFC 2616. To change this use the DecoderConfig, e.g.
	RestAssured.config = newConfig().decoderConfig(decoderConfig().defaultContentCharset("UTF-8"));
* Fixed a bug when setting content type to JSON and using a byte array as body (issue 156).
* Multi-headers and multi-cookie cookie parsing now uses ignore-case equals to identify the entity.
* Upgraded to Hamcrest 1.2.1 and changed the ResponseSpecification to allow for more flexible argument matchers.
* Fixed a bug with the cookie parsing which couldn't deal with cookie values including an equal character (issue 159).
* Added support for argument lists in root and rootPath methods in the response specification (issue 117).
* Request logging filter now logs base path and base uri (issue 145).
* Added method getCompleteRequestPath to com.jayway.restassured.filter.FilterContext. This method provides the fully-qualified URL including scheme and port number to the request path.
* Fixed content encoding for content types ending with +xml, +json and +html to automatically be encoded using the correct encoder methods (issue 160).

Changelog 1.5 (2011-12-20)
---------------------------
* Added methods "noFilters" and "noFiltersOfType" to RequestSpecification to allow for removal of filters. This is useful when specifying a default filter statically (e.g. a custom authentication filter) but you need to remove it in a Filter implementation in order to make requests without this filter.
* Improved JsonPath to automatically convert e.g. ints to Strings if explicitly requested.
* Fixed an issue with detailed cookie parsing that prevent the "secured" attribute to be parsed correctly.
* Fixed a bug that failed to apply the root path for multi-body expectations, e.g this will now work:
   expect().
          root("store.book").
          body(
             "category.size()", equalTo(4),
             "author.size()", equalTo(4)
          ).
   when().
          get("/jsonStore");
  (issue 135)
* Fixed a bug with automatic port detection for certain base URI's.
* Improved merging of baseUri, basePath and path. E.g. if the baseUri ends with slash and the path starts with slash one of the slashes are automatically removed (issue 134).
* java.util.Locale will never be serialized to JSON/XML when provided in as a parameter object
* Fixed an issue with PUT method duplicating form parameters as query parameters (issue 137)
* Fixed so that JSON path fragments starting with @ are escaped automatically (issue 138).
* Fixed a serious bug in the response parsing which ignored changes made to the response from a filter when using the DSL (issue 139).
* Created a ResponseBuilder to make it easier to create new Response implementations. This is useful if you're working with filters and want to change the response you get from the sever somehow. E.g.
	Response myResponse = new ResponseBuilder().clone(originalResponse).setBody("Something").build();
* Allows configuring redirect settings using the DSL, e.g.
	given().redirects().max(12).and().redirects().follow(true).when(). .. (issue 24)
* Support for passing in a keystore located on the file-system, e.g.
	given().keystore(new File(".."), "password"). ..
  or for all requests:
	RestAssured.keystore(new File(".."), "password"). ..
  You can also specify the path to the file system as a string as well:
       	given().keystore("some/path/my_keystore.jks", "password"). ..
  In this case REST Assured will first try to find the keystore in the classpath but if it was not found it will look in the file-system (issue 136).
* Status code and status line are now validated before headers and cookies (issue 131).
* Quotes from strings in error messages has been removed.
* Added possibility for more advanced configuration by providing a RestAssuredConfig instance. Right now you can configure the parameters of HTTP Client, Redirect and Log settings. Examples:
  For a specific request:
	given().config(newConfig().redirect(redirectConfig().followRedirects(false))). ..
  or using a RequestSpecBuilder:
	RequestSpecification spec = new RequestSpecBuilder().setConfig(newConfig().redirect(redirectConfig().followRedirects(false))).build();
  or for all requests:
	RestAssured.config = config().redirect(redirectConfig().followRedirects(true).and().maxRedirects(0));
  "config()" and "newConfig()" can be statically imported from com.jayway.restassured.config.RestAssuredConfig
* Non-backward compatible change: getRequestParams and getQueryParams() now returns Map<String, ?> instead of Map<String, String> in FilterableRequestSpecification.
* Added getFormParams() and getPathParams() to com.jayway.restassured.specification.FilterableRequestSpecification.
* Header- and Cookie names are now case-insentive in com.jayway.restassured.response.Headers and com.jayway.restassured.response.Cookies.
* Added a new method called filters(Filter filter, Filter...additionalFilter) in the com.jayway.restassured.specification.RequestSpecification and com.jayway.restassured.RestAssured.
* Logging has undergone a major uplift. You can now not only log the response body but also headers, cookies and status line. You can also log the request details as defined in the request specification. Thus the following:
	given().log(). .. // Log the response body in versions prior to 1.5
  and
	expect().log(). .. // Also logs the response body in versions prior to 1.5
  will now look like this:
	given().log().body(). .. // Log the _request_ body in versions >= 1.5
  and
	expect().log().body() .. // Log the response body in versions >= 1.5
  You can also log e.g. only headers in the request and the response:
	given().log().headers(). .. // Log only the request headers
  and
	expect().log().headers(). .. // Log only the response headers
  Previously there was a method called "logOnError" in both the request and response specification. This has now been replaced with the following method in the response specification:
	expect().log().ifError(). ..
  This change is not backward compatible (issue 81).

Changelog 1.4.5 (2011-11-08)
-----------------------------
* REST Assured can now parse responses with no-value (empty) cookies (issue 124).
* Added support for serializing objects to a parameter if the content-type is set:
  given().
          contentType("application/json").
          queryParam("category", "Games").
          formParam("object", new GameObject(..)). // GameObject will be serialized to JSON
  when().
          post("/somewhere");
  (issue 127).
* Fixed a bug with multi-value form parameters when using PUT.
* You can now create multi-value headers using e.g.: given().header("headerName", "value1", "value2")... This will create TWO headers, "headerName=value1" and "headerName=value2".
* You can now create multi-value cookies using e.g.: given().cookie("cookieName", "value1", "value2")... This will create TWO cookies, "cookieName=value1" and "cookieName=value2".
* Fixed a bug in the specification merger which caused FormAuthFilters to be applied twice if using multiple specifications with form auth.
* Fixed a serious bug in the cookie response parsing that caused cookie attributes to be parsed as a new cookie (issue 130).
* This version introduces a number of non-backward compatible change: The headers() and getHeaders() methods in com.jayway.restassured.response.Response no longer return a Map of key-value pairs, it now returns an instance of com.jayway.restassured.response.Headers. The reason for this is to allow for multi-value headers. These are headers that has several values for the same header name, e.g. "headerName=value1" and "headerName=value2". See javadoc in com.jayway.restassured.response.Headers for more info.
* Added support for getting "detailed cookies". A detailed cookie contains information such as Expiry Date, Path, Version etc. To get a detailed cookie use com.jayway.restassured.response.Response#getDetailedCookie(<cookie name>) or to get all use com.jayway.restassured.response.Response#getDetailedCookies().
* Added support for sending detailed cookies, e.g.
	Cookie someCookie = new Cookie.Builder("some_cookie", "some_value").setSecured(true).build();
	given().cookie(someCookie).and().expect().body(equalTo("x")).when().get("/cookie");
  you can also send multiple detailed cookies at the same time:
  	Cookie cookie1 =  Cookie.Builder("username", "John").setComment("comment 1").build();
	Cookie cookie2 =  Cookie.Builder("token", 1234).setComment("comment 2").build();
	Cookies cookies = new Cookies(cookie1, cookie2);
	given().cookies(cookies).then().expect().body(equalTo("username, token")).when().get("/cookie");
  (issue 99).
* Added support for mapping a path to a Java object in JsonPath, e.g: Book book = from(JSON).getObject("store.book[2]", Book.class); (half of issue 125)

Changelog 1.4 (2011-10-07)
---------------------------
* Better error message when an actual JSON or XML path value doesn't match the expected value (issue 104).
* Removed dependency to spring-web in example project
* Improved support for getting a list with an explicit type using XmlPath (issue 106).
* RestAssured.baseURI now works as expected. You can now use e.g. RestAssured.baseURI = "http://somehost.org:1234" and the subsequent requests will automatically go to that URI as base (issue 54).
* Rest Assured now throws a java.lang.AssertionError instead of AssertionFailedException (issue 100).
* Added support for setting a default Parser. This parser will automatically be used to parse all responses whose content-type doesn't match a pre-defined parser. You can set the default parser for all responses using:
	  RestAssured.defaultParser = Parser.JSON;
  or for a single response:
	  expect().defaultParser(Parser.JSON).when(..).
  or using a response specification builder:
	  new ResponseSpecBuilder().setDefaultParser(Parser.JSON).build();
 (issue 107).
* Improved parsing of response content. If no body expectations are defined then the content is no longer encoded to an intermediate data structure when calling methods such as "asString", "asByteArray" etc on the Response object. This increases the performance of Rest Assured when using no body expectations (e.g. get("/something").asString()) (issue 109).
* Added an "asInputStream" to the Response object. This means that you can now do e.g. "get("/something").asInputStream()" to get the body returned as an input stream.
* Support for mapping a response content body directly to an Object using either Jackson or Gson for JSON responses and JAXB for XML responses. Usage example:
	SomeObject someObject = get("/something").as(SomeObject.class);
  This requires the the response content-type is defined. If you want to map the response using a specific object mapper you can do like this:
		SomeObject someObject = get("/something").as(SomeObject.class, ObjectMapper.GSON);
  Note that Rest Assured doesn't explicitly depend on any of the object mappers so you need to add them to the classpath manually or using a Maven dependency (issue 19).
* Support for mapping a Java Object to JSON or XML using Jackson, Gson or JAXB. Use e.g. "given().contentType("application/json").and().body(someObject).when().post("/something");"
  You can also specify an explicit object mapper instead of a content-type:
	given().body(someObject, ObjectMapper.JACKSON).when().post("/something");
  (issue 118).
* getMap with explicit type now converts the key and value to the defined type for both JsonPath and XmlPath
* JsonPath.getList with an explicit type now converts all list members to the defined type (issue 114).
* Fixed a bug when defining root path that ends with a dot and a path that starts with a dot.
* You can now provide ints, floats etc to the request body. E.g. given().body(42).when().post("/somewhere");
* getString in JsonPath converts the result to string if needed (issue 115).
* Added "path", "jsonPath" and "xmlPath" methods to ResponseBody object. This make it very convenient to make a request and parse a single path from the response. E.g.
    String messageBody = get("/message").path("message.body");
  In this example the response content-type determines whether JsonPath or XmlPath should be used. It could also be defined explicitly:
    String messageBody = get("/message").jsonPath().getString("message.body");
  (issue 110, 116).
* Fixed a bug when using a form auth per request and a default form auth which added two form auth filters to the filter list causing multiple requests to made to the server.

Changelog 1.3.1 (2011-09-20)
-----------------------------
* Fixed a trivial bug in the error message that is displayed when no parser is found for a certain content type (issue 103).
* Fixed a bug that caused the response body to be parsed as JSON if Content-Type of the response was JSON even though no body matchers were specified (issue 102).
* Improved List parsing with XmlPath. E.g. from(XML).getList("shopping.category.item.price") will now automatically convert the output from NodeChildren to a List. Also from(XML).getList("shopping.category.item.price", Float.class) will automatically convert all list members to floats.
* When result from XmlPath expression is a single entity it's treated as a list if explicitly defined: E.g. from(XML).getList("shopping.category.item.price[0]") and from(XML).get("shopping.category.item.price.list()") will return a list (issue 59).
* All parameter values now take Object as parameter type. This means that you can supply e.g. ints, floats etc and not only Strings as parameter values. E.g. before you had to do given().param("number", String.valueOf(1)).when().get(..) but now you can simply do given().param("number", 1).when().get(..); (issue 82).
* You can now register custom parsers directly in the response specification and the response specification builder and not only statically in the RestAssured class. E.g. expect().parser("some/xml", Parser.XML).when().get("/something"); (issue 101).

Changelog 1.3 (2011-09-05)
---------------------------
* Added support for uploading files, input streams, byte arrays and text using multi-part form data upload. You can use the "multiPart" method to specify what to upload. E.g.
  given().multiPart(new File("/home/user/myFile.txt").when().post("/upload"); (issue 93)
* Request specification details such as port number are now taking into account when using form authentication (issue 95).
* You can now pass string data to the content method in the RequestSpecification, e.g. given().content("{ \"message\" : \"hello world
\"}").then().expect().statusCode(200).when().post("/json");
* Added methods to get NodeChildren and Node to XmlPath class (issue 54 and 58).
* Improved automatic escaping of attributes in cases of ranges. E.g. you can now type "records.car[0..1].@year" when parsing XML instead of having to escape the year attribute like "records.car[0..1].'@year'".
* Improved escaping of the minus character inside closures when parsing JSON, XML and HTML.
* When using XmlPath and getting primitive values from an XML graph the result is automatically converted to the expected primitive type if needed and possible.
* Added support for depth-first parsing of XML using the double-star notation, e.g. "int chocolatePrice = from(XML).getInt("shopping.**.find { it.name == 'Chocolate' }.price");" (issue 94).
* RestAssured now uses the threads classloader to load net.sf.json.AbstractJSON instead of root classloader to avoid problems with Groovy Grape (issue 92).
* When specifying a request body and using a custom/unregistered content-type the body will automatically be URL Encoded. Previously a NPE was thrown because no content encoder was registered to HTTP Builders encoder registry for the specified content type. (issue 96).
* Fixed a bug in RequestSpecificationBuilder that treated form parameters as query parameters.

Changelog 1.2.3 (2011-08-18)
-----------------------------
* Fixed a bug when using PUT with multi-value form parameters.
* Improved path parameter support. Rest Assured no longer URL encodes path parameters in order to detect them as query parameters.
* JsonPath now converts from Groovy primitives to Java primitives correctly (thanks to Erik Hjortsberg)
* Added support for enabling and disabling URL encoding for parameters. This is useful if the parameters are URL encoded before you supply them to Rest Assured. In cases like this you need to use given().urlEncodingEnabled(false), RestAssured.urlEncodingEnabled = false or specify it using the RequestSpecificationBuilder to avoid double URL encoding (issue 88).
* Fixed URL to web page in pom.xml (issue 90)
* Added a no-argument get method to JsonPath and XmlPath to easier parse the entire object graph (issue 91).
* Better support for re-usable path expressions by using arguments. E.g. let's say you want to expect a complex path like this:
	  expect().
		   body("filters.filterConfig[0].filterConfigGroups.find { it.name == 'GroupName' }.includes", hasItem("first")).
		   body("filters.filterConfig[1].filterConfigGroups.find { it.name == 'GroupName' }.includes", hasItem("second")).
          ..
  The only difference between the two body paths is the index of the "filterConfig". A root path wouldn't help since previously you could only append a path to the root path and not supply arguments to it. Now you can do:
  	  expect().
		   root("filters.filterConfig[%d].filterConfigGroups.find { it.name == 'GroupName' }.includes").
		   body("", withArgs(0), hasItem("first")).
		   body("", withArgs(1), hasItem("second")).

  I.e. the indices 0 and 1 was replaced with a "%d" and you then supply the arguments to the path expression using the "withArgs" method located in com.jayway.restassured.RestAssured. You can also use the "withArgs" method without
  using a root-path (issue 17, 80).

Changelog 1.2.2 (2011-06-28)
-----------------------------
* Added support for parsing an entire JSON graph. E.g. let's say you have a JSON snippet like this:
  [{"email":"name1@mail.com","alias":"name one","phone":"3456789"},
   {"email":"name2@mail.com","alias":"name two","phone":"1234567"},
   {"email":"name3@mail.com","alias":"name three","phone":"2345678"}]
  You can then parse the entire JSON snippet to a List of Map like this:
     List<Map<String, String>> result = from(json).get("$");
  or
   List<Map<String, String>> result = from(json).get("");
  (issue 78)
* Added support for explicitly specifiying form parameters, e.g. using given().formParam("name", "value"). This is useful e.g. when sending a PUT request with both form params and query params (issue 75).
* It's now possible to check that a header does NOT exist: expect().header("someheader", nullValue()). (issue 74).
* Support for path parameters. E.g. get("/{firstName}/{lastName}", "John", "Doe") will send a GET request to "http://localhost:8080/John/Doe". You can also specify path params like this:
  given().
          pathParam("firstName", "John").
          pathParam("lastName", "Doe").
  when().
          get("/{firstName}/{lastName}");
 (issue 36)
* Support for specifying a Java keystore when using SSL. This is useful when you run into e.g. SSLPeerUnverifiedException when the server has an invalid certificate. Usage:
  given().keystore("/pathToJksInClassPath", <password>)
  For more info refer to https://github.com/jgritman/httpbuilder/wiki/SSL (issue 79).
* Fixed an issue that could cause parameters to be treated as lists parameters.

Changelog 1.2.1 (2011-05-23)
-----------------------------
* Fixed an issue when defining default request specifications with form parameters when using POST.
* Added support for getting the content type in the com.jayway.restassured.response.Response object.
* Fixed a major issue with filters that caused the response expecations to be verified before filter chain was completed.
* Added "from" method to XmlPath and JsonPath (issue 60).
* XmlPath now supports parsing HTML by setting CompatibilityMode to HTML, e.g. new XmlPath(CompatibilityMode.HTML, <some html>);.
* Form authentication now uses HTML parsing when parsing the login page (before XML parsing was used which was very fragile).
* Improved HTML parsing with Groovy closures

Changelog 1.2 (2011-05-22)
---------------------------
* Better support for multi-value parameters. You can now defined them using a List:
    with().param("list", asList("1", "2", "3)). ..
  or with var-args:
    with().param("list", "1", "2", "3). ..
* Added support for form authentication: given().auth().form("username", "password")... Rest Assured will automatically parse the login page and try to find the form action and the username and password input fields. If it fails to do so or if you want a faster request you can supply a FormAuthConfig as a third param that providers Rest Assured with these parameters. E.g. given().auth().form("username", "password", new FormAuthConfig(..)).. There's a pre-defined form auth config for Spring Security: given().auth().form("username", "password", FormAuthConfig.springSecurity())... You can also specify form as default authentication for all requests: RestAssured.authentication = form("username", "password");. (issue 61).
* Added support for filters with which you can inspect and alter a request before it's actually committed and also inspect and alter the response before it's returned to the expectations. You can regard it as an "around advice" in AOP terms. Filters can be used to implement custom authentication schemes, logging, session management etc. You implement com.jayway.restassured.filter.Filter and register it using: given().filter(new MyFilter()). .. or set it as default: RestAssured.filters(asList(new MyFilter()); (issue 71).
* You can now define and expect cookies without values using e.g. given().cookie("some_cookie").. or expect().cookie("some_cookie").. (issue 69).
* You can now specify default request and response content type using RestAssured.requestContentType(..) and RestAssured.responseContentType(..). (issue 68).
* Support for specifying string content types (issue 72).
* Support for specifying default request and response specifications (issue 67).
* Added support for printing response body using filters. E.g. given().filter(ErrorLogger.errorLogger()).. will print the response body if an error occurred (400 <= status code <= 500). You can also use the ResponseLoggingFilter to print response bodies for all status codes: given().filter(ResponseLoggingFilter.loggingFilter()).., or you can make it print only for specific status codes: given().filter(ResponseLoggingFilter.logResponseIfStatusCodeIs(302)).. and you can even use Hamcrest matchers: given().filter(ResponseLoggingFilter.logResponseIfStatusCodeIs(greaterThan(200)))..
  There's also a shortcut for error logging:
    given().logOnError(). or expect().logOnError(). ..
  and for logging:
    given().log(). or expect().log(). (issue 66).
* Added support for easily printing the response after a request (if the expectations pass), e.g. expect().body("greeting", equalTo("Greetings John Doe")).when().get("/greet?firstName=John&lastName=Doe").print();

Changelog 1.1.7 (2011-04-26)
-----------------------------
* Added support for mixing form and query parameters when using the POST method. E.g. "with().param("firstName", "John").and().queryParam("lastName", "Doe").expect().body("greeting.lastName", equalTo("Doe")).post("/greetXML");"
  When using POST the "param" method adds form parameters to the request and "queryParam" adds query parameters of the request.
* Added support for multi-value paramters, e.g. with().param("list", "first").and().param("list", "second").when().get("/something") will now send a GET request to "/something" with parameter list including first and second. (issue 62).

Changelog 1.1.6 (2011-03-29)
-----------------------------
* Preemptive basic authentication really works (issue 52).

Changelog 1.1.5 (2011-03-28)
-----------------------------
* Added suport for preemptive basic authentication. E.g. given().auth().preemptive().basic("username", "password").when().get("/secured");. You can also set preemptive basic authentication as default authentication scheme using:
  RestAssured.authentication = preemptive().basic("username", "password"); (issue 45)
* Added support for specifying a root path. E.g. instead of writing:
  expect().
           body("x.y.firstName", is(..)).
           body("x.y.lastName", is(..)).
           body("x.y.age", is(..)).
           body("x.y.gender", is(..)).
  when().
           get("/something");
  you can use a root path and do:
  expect().
           rootPath("x.y").
           body("firstName", is(..)).
           body("lastName", is(..)).
           body("age", is(..)).
           body("gender", is(..)).
  when().
          get("/something");
  You can also set a default root path using: RestAssured.rootPath = "x.y"; (issue 47)
* It's now possible to reuse specifications accross different tests (issue 46). E.g.
  ResponseSpecification responseSpec = new ResponseSpecBuilder().expectStatusCode(200).expectBody("x.y.size()", is(2)).build();

  expect().
         spec(responseSpec).
         body("x.y.z", equalTo("something")).
  when().
         get("/something");

  The "responseSpec" can now be reused in a completely different test without having to duplicate the expecations in the "responseSpec" for each test.

  The same thing can be achieved for request specifications:
  RequestSpecification requestSpec = new RequestSpecBuilder().addParameter("parameter1", "value1").build();

  given().
          spec(requestSpec).
  expect().
          body("x.y.z", equalTo("something")).
  when().
          get("/something");
* You can now get the response body content when request body is empty (issue 49).
* Added support for getting response body even when using body expecations. I.e. now this works:
  String body = expect().body("x.y.z", equalTo("something")).when().get("/x").andReturn().body().asString(); (issue 50)
* Specifying a fully-qualied request url overrides default base path, base uri, and port (issue 41).

Changelog 1.1.2 (2011-03-04)
-----------------------------
* Fixed so that POST requests can return a response (e.g. Response response = post("/somewhere");) when an error occurred (status code 400 to 999). (issue 37).
* You can now get the status line and status code from the Response (issue 40). E.g
      Response" response = get("/something");
      String statusLine = response.getStatusLine();"
* Corrected some javadoc issues.

Changelog 1.1.1 (2011-03-02)
-----------------------------
* Added support for getting headers and cookies from the Response, e.g. String headerValue = get("/something").andReturn().header("headerName"); (issue 27)
* Fixed so that you don't need to add a "@" when calling getAttribute(..) on Node in XmlPath (issue 34)
* Added support for validating XML body using XSD e.g. "expect().body(matchesXsd(xsd)).when().get("/carRecords");" where matchesXsd(..) is a REST-Assured Hamcrest matcher located in com.jayway.restassured.matcher.RestAssuredMatchers and "xsd" can be either a String, InputStream, Reader, URL or File (issue 29).
* Added support for validating XML body using DTD e.g. "expect().body(matchesDtd(dtd)).when().get("/videos");" where matchesDtd(..) is a REST-Assured Hamcrest matcher located in com.jayway.restassured.matcher.RestAssuredMatchers and "dtd" can be either a String, InputStream, URL or File (issue 29).
* Improved error messages on illegal paths when expecting XML (issue 35).


Changelog 1.1 ((2011-02-18)
----------------------------
* Added support for specifying base path using "RestAssured.basePath = /resource". E.g. let's say that the base URI is http://localhost and base path is "/resource" will make create a request to "http://localhost/resource/something" when doing a 'get("/something")'. Default value is empty. (issue 13)
* Support for specifying request/query parameters in the url, e.g. get("/something?param1=first&param2=second"). (issue 23)
* Fixed a bug in RestAssuredResponse parser that caused a NPE when the input stream was null. (issue 25)
* Major improvements to XML expectations. It now uses Groovy syntax for the expectation string to allow for much better expectations! Note that this fix will break backward compatibility on some expectations. E.g. given
        <greeting>
	    <name>
                <firstName>John</firstName>
                <lastName>Doe</lastName>
            </name>
        </greeting>
  you used to do:
        expect().body("greeting.name", hasItems("John", "Doe"))..
  Now this will not work, instead you have to do:
        expect().body("greeting.name.children()", hasItems("John", "Doe"))..
  But this also means that you can do:
        expect().body("greeting.name.size()", equalsTo(2))..
  See http://www.groovy-lang.org/processing-xml.html#_manipulating_xml for more info about the syntax.
* Support for expecting on XML attributes, e.g. expect().body("greeting.name.@firstName", equalTo("John")).when().get("/greetXMLAttribute?firstName=John&lastName=Doe");
* When forcing plain text verification for e.g. JSON or XML responses the response content type is no longer changed. Before this could cause Jersey to refuse to refuse the return a response. (issue 10)
* PUT requests now supports specifying binary a request body
* Major improvements to JSON expectations. It now uses Groovy syntax for the expectation string to allow for much better expectations! Note that this fix will break backward compatibility on some expectations.
  - JSON lists are always returned as Java lists which means that you should use the hasItem(..) hamcrest matcher and not hasItemsInArray(..) hamcrest matcher.
* Added support for specifying default authentication scheme. E.g. use RestAssured.authentication = basic("username", "password") to cause all subsequent request to use basic authentication. You can reset to no authentication using RestAssured.reset(); (issue 20)
* Added support for registering a predefined parser for unsupported mime-types by using RestAssured.registerParser(<mime-type>, <parser>). E.g. to register that mime-type 'application/vnd.uoml+xml' should be parsed using the XML parser do: RestAssured.registerParser("application/vnd.uoml+xml", Parser.XML);. You can also unregister a parser using RestAssured.unregisterParser("application/vnd.uoml+xml");. (issue 8)
* Added XmlPath object which allows you to parse an XML response from a request easily. E.g.
  String xml = post("/greeting").asString();
  String firstName = with(xml).get("greeting.firstName");
  For more information refer to the javadoc of com.jayway.restassured.path.xml.XmlPath
* Added JsonPath object which allows you to parse an JSON response from a request easily. E.g.
  String json = post("/greeting").asString();
  String firstName = with(json).get("greeting.firstName");
  For more information refer to the javadoc of com.jayway.restassured.path.json.JsonPath

Changelog 1.0.3 (2011-01-17)
-----------------------------
* Fixed a bug in the JSON parsing which prevent parsing of nested arrays (issue 15)
* Added support for getting an index in a JSON array. E.g. expect().body("items.get(0)", equalTo("firstIndex")).when().get("/something");. Assuming that "items" is an array then "items.get(0)" returns the first element in that array.
* Fixed so that you can expect on null values in JSON arrays.
* Request senders can now return the body as byte array or string. E.g. get("/something").asString() makes GET request to "/something" and returns the response body as a string. This is useful if you want to debug the response while creating your test or if you want to use third-party tools to validate the response. Note that it only works if you don't specify any expectations before making the request.

Changelog 1.0.2 (2011-01-12)
-----------------------------
* JSON and XML matching now supports many more content types than before. Before you could only use XML matching for content type application/xml and JSON for application/json.
* Support for HTML verification
* Support for RSS verification (content type application/rss+xml)

Changelog 1.0.1 (2010-12-27)
-----------------------------
* Refactored AuthenticationSpecification to be a Java interface in order to avoid Groovy methods being exposed and to allow for Javadoc.
